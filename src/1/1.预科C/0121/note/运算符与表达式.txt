1.表达式
    什么是一个表达式?
        表达式就是能够表达某种意思的式子
        a = b + c   //把b和c相加的值赋值给a

    在C语言中,我们一般表达式指的是 运算符和操作数所连接在一起的式子
        a+b  2+2 5 999

        a = b + c//表达式  
        a = b + c;//C语言语句

        在C语言中,表达式是运算符连接的式子,我们一般认为,表达式带分号就是语句
        不带分号就是一个表达式

    注意:
        表达式一定是有一个确定的值


2.运算符 
    什么是运算符?
        我们用来运算的符号
        比如:+ - * / % | & ....
    
    几目运算符:
        表示该运算符需要多少个操作数

        单目运算符:表示该运算符需要连接1个操作数,比如:!,++,--...
        双目运算符:表示该运算符需要连接2个操作数,比如:+,-,*,%...
        三目运算符:表示该运算符需要连接3个操作数,比如: ? :(条件运算符)


    结合性:
        代表运算符的优先顺序
        例子:
            + 结合性: 从左往右

            a + b 
            (1+2) + (3+4)
            这个表达式 先算a的值 在算b的值
            所以,在C语言中,a + b 和 b + a是有区别的


    (1)算术运算符
            进行算术运算
            单目运算符: ++ , -- 

            双目运算符: +,-,*,/.%
            结合性:从左往右

        1)/ 取整
            整数除以整数,结果还是一个整数,如果要变成实数,那么把分子乘1.0
                5/2 ==> 2
                1.0*5/2 ==> 2.5
            ==============================================
                隐式类型转换:
                    高精度的数据和低精度的数据进行运算的时候,结果会
                    自动向高精度转换
                比如:
                    int double -> double
                    int short -> int 
                    char int -> int
                    无符号 有符号 -> 无符号

                例子:
                    char a = '0';
                    char b = 1;
                    printf("%d\n".a+b);
        
        2)%取余
            在C语言中,取余的两个操作数必须是整数
                5%3 -> 2
                -5%3 -> -2
                5%-3 -> 2
                -5%-3 -> -2
            结论:余数的符号和被除数的符号一致

        3)自增++ 自减--
            ++:让这个操作数+1
            --:让这个操作数-1
            注意:
                a.自增和自减只能够用于变量
                    i++;//i = i+1
                    5++;//5 = 5+1
                    (a+b)++;//a+b是一个表达式
                    (a++)++;//a++是一个表达式

                b.
                            表达式的值   执行后i的值
                    i++         i           i+1         //先赋值 后运算
                    ++i        i+1          i+1         //先运算 后赋值
                    i--         i           i-1
                    --i        i-1          i-1

            例子:
                a = ++i;
                ===>
                    {
                        i = i+1;
                        a = i;
                    }

                a = i++;
                ===>
                    {
                        a = i;
                        i = i+1;
                    }

            练习:
                1)
                    int i = 5;
                    int a = i++;//a:5 i:6
                    int b = ++i;//b:7 i:7
                    int c = i--;//c:7 i:6
                    int d = --i;//d:5 i:5


                2)
                    int i = 6;
                    printf("%d %d\n",i++,++i);// 6 8,

    (2)关系运算符
        用来判断两个表达式的数值大小关系的运算符
        双目运算符,结合性从左往右

        == <= < != > >=

        关系表达式:
            由关系运算符连接的表达式

            关系表达式的值只有两种情况:1(关系成立) 0(关系不成立)

        例子:
            5 > 4 --->  1(关系成立)
            3 > 4 --->  0(关系不成立)
            5>4>3   ----> 0(关系不成立)
            5>4>3----> 
                        5>4--->1(成立)
                        ==>
                        1>3--->0(不成立)

            数学上 5>4>3 是成立的,那么,在C语言中,如何表示这个关系?
                5>4 并且 4>3
    
    (3)逻辑运算符 
        表达某种梳理逻辑的运算符
            &&  逻辑与  双目运算符 "并且" 结合性:从左往右
            ||  逻辑或  双目运算符 "或者" 结合性:从左往右
            !   逻辑非  单目运算符 "取反"

        逻辑表达式:
            用逻辑运算符连接的表达式
            逻辑表达式的值只有两种情况:
                逻辑真1(真,非0)
                逻辑假0
                任何非0的数都是表示真,但是逻辑表达式为真,值还是1

        例子:
            int a = 4,b = 5;
            a && b  ->  1 
            a && 0  ->  0   只要有一个值为0,表达式的结果就是0
            a || b  ->  1   
            a || 0  ->  1   只有有一个为1,表达式的值就是1

            0与任何数&&都是0,1与任何数||都是1 

        练习:
            int a = 1,b = 2,c = 3,d = 4,m = 1,n = 1;
            (m = a>b)&&(n = c>d);
            printf("%d %d %d %d %d %d\n",a,b,c,d,m,n);// 1 2 3 4 0 1
            因为&&的结合性是从左往右的
                所以先算(m = a>b)
                    a>b -> 1>2===>0
                    m = a>b ====> m = 0 ====> 0
                    因为0&&任何一个数都是0,所以后面的就不用计算了
                    这种计算机的计算方式叫做惰性运算
            惰性运算:
                假设我们事先知道了表达式的结果了,那么后面的运算就不会在继续进行了

            比如:
                a && b && c 
                只有a的值为真(非0),才会去计算b的值
                只有当a和b的值都为真(非0),才会计算c的值

                a || b || c 
                只有当a的值为假(0)的时候,才会计算b的值 
                只有当a和b的值都为假(0)的时候,才会计算c的值 

    (4)位运算符
        位运算符是按bit来进行运算的
            注意:位运算符只能够作用于整数
        
        ~按位取反
        &按位与
        |按位或
        ^按位异或
        <<按位左移
        >>按位右移

        只有按位取反是单目运算符,其余的都是双目运算符,结合性从左往右
        运算步骤:首先把操作数(整数)分解乘bit序列(补码),然后在按照bit位进行运算

        1)按位取反~
            0->1 1->0

            例子:
                int a = ~3;
                printf("%d\n",a);
                printf("%u\n",a);

                S1:取3的补码
                3:00000000 00000000 00000000 00000011   (int)
                ~:11111111 11111111 11111111 11111100   a(int)

                %d:先看符号位   1 负数  补码还原
                    a:11111111 11111111 11111111 11111100
                   -1:11111111 11111111 11111111 11111011
                    ~:00000000 00000000 00000000 00000100
                得到了a的绝对值的补码
                    a的值:-4
                
                %u:直接按照补码求权值然后输出
                    2^32-4


                int a = ~(-3);
                printf("%d\n",a);
                printf("%u\n",a);
                S1:求-3的补码
                    |-3| 3:00000000 00000000 00000000 00000011 
                         ~:11111111 11111111 11111111 11111100
                        +1:11111111 11111111 11111111 11111101      -3

                       -3:11111111 11111111 11111111 11111101
                        ~:00000000 00000000 00000000 00000010   a(int)
                    
                    %d:
                        看符号位 0 正数 
                        直接输出:2
                    
                    %u:直接输出:2

        2)按位与 &
            a b a&b 
            1 1  1
            1 0  0
            0 1  0
            0 0  0
            结论:只有两个bit位都为1,结果才是1,否则结果为0   "有0则0,全1为1"

            例子:
                int a = 3&5;
                printf("%d\n",a);
                printf("%u\n",a);

                3:00000000 00000000 00000000 00000011 
                5:00000000 00000000 00000000 00000101 
              3&5:00000000 00000000 00000000 00000001  

                %d:1
                %u:1

            结论:
                任何一个bit为与0进行按位与&,结果都是0
                    x&0 = 0
                任何一个bit位与1进行按位与&,结果都是原值 
                    x&1 = x
        
        3)按位或|
            a b a|b 
            1 1  1
            1 0  1
            0 1  1
            0 0  0
            只有两个bit位都位0,结果才是0,否则都是1 "有1则1,全0才0"

            例子:
                int a = 3|5;
                printf("%d\n",a);
                printf("%u\n",a);
                3:00000000 00000000 00000000 00000011 
                5:00000000 00000000 00000000 00000101 
              3|5:00000000 00000000 00000000 00000111

                        7

            结论:
                任何一个bit位与0进行按位或|,结果都是原值
                    x | 0 = x
                任何一个bit位与1进行按位或|.结果都是1 
                    x | 1 = 1

        4)按位异或^
            异或:求异
            a b a^b 
            1 1  0
            1 0  1
            0 1  1
            0 0  0

            "相同为0 不同为1"

            例子:
                int = 3^5;
                printf("%d\n",a);
                printf("%u\n",a);
                3:00000000 00000000 00000000 00000011 
                5:00000000 00000000 00000000 00000101 
              3^5:00000000 00000000 00000000 00000110   ---> 6

            结论:
                任何一个bit位与0进行"按位异或^"运算时,结果保留原值
                    x^0 = x;
                任何一个bit位与1进行"按位异或^"运算是,将结果取反
                    x^1 = ~x;

        
        练习:
            交换两个整数a和b的值,不使用临时变量
            int a = 5;
            int b = 6;

            int temp = a;
            a = b;
            b = temp; 


            方法1:
                a = a + b;//a = 11
                b = a - b;//11 - 6 = 5
                a = a - b;

            方法2:
                a = a^b;
                b = b^a;
                a = a^b;
                ======================================
                a b  a=a^b b=b^a a=a^b  a b 
                1 1  0     1     1      1 1
                1 0  1     1     0      0 1
                0 1  1     0     1      1 0
                0 0  0     0     0      0 0

                =======================================
                a:0000 1010
                b:1111 0010
                a = a^b;
                b = b^a;
                a = a^b;
                a:1111 0010
                b:0000 1010

                注意:
                    位运算只和当前bit位有关,既没有错位,也没有进位
                        a:5 b:6
                5:0000 0101     
                6:0000 0110
                ^:0000 0011 3 ===> a = a^b  3


                6:0000 0110
                3:0000 0011
                ^:0000 0101  ====> b = b^a = 5

                3:0000 0011
                5:0000 0101 
                ^:0000 0110   =====> a = a^b = 6  
        
        5)按位左移 <<
            按bit位整体的向左移
            a << n
            规则:
                把a转化二进制序列(补码),再按照bit位进行向左偏移n位
                    高位就会舍弃n位,低位补n个0

            
            例子:
                char a = 5 << 3;
                S1:
                    求出5的补码:
                        00000101 
                    <<2:00010100    20  5 * 2^2
                    <<3:00101000    40  5 * 2^3
                    <<4:01010000    80  5 * 2^4
                    <<5:10100000    160 5 * 2^5
                    <<6:01000000    64

            结论:
                如果按位左移舍弃的高位全部是0,那么左移n位,他的值就是原值乘2的n次方


            练习:
                假设有一个整型变量(int)a,要把a的第5个bit变成0,其他位保持不变
                注意:
                    这个整数的第多少位,表示是0开始

                    xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx


                 &  11111111 11111111 11111111 11011111 
                 ~  00000000 00000000 00000000 00100000   1<<5
                    00000000 00000000 00000000 00000001

                ==> xxxxxxxx xxxxxxxx xxxxxxxx xx0xxxxx

                  a = ~(1<<5) & a;
                  a = ~32 & a

                  要求:尽量以最简单的形式表达出运算

        6)按位右移 
            将bit位整体向右移动
                a >> n
                规则:先把a转化成二进制序列(补码),再按照bit位整体向右偏移n位
                        低位直接舍弃掉n位,高位根据数据类型来看
                        如果没有符号位的概念,高位直接补0
                        如果有符号位的概念,高位补符号位


            练习:
                (1)
                    int a = -1;
                    a = a >> 31;
                    printf("%d\n",a);
                    printf("%u\n",a);

                    S1:求出-1的补码形式
                    |-1| 1: 00000000 00000000 00000000 00000001
                       取反: 11111111 11111111 11111111 11111110
                       +1:  11111111 11111111 11111111 11111111
                     >>31:  11111111 11111111 11111111 11111111

                     %d:
                        补码还原 
                            -1 
                    %u: 2^32-1



                (2)
                    unsigned int a = -1;
                    a = a >> 31;
                    printf("%d\n",a);
                    printf("%u\n",a);

                    S1:求出-1的补码形式
                    |-1| 1: 00000000 00000000 00000000 00000001
                       取反: 11111111 11111111 11111111 11111110
                       +1:  11111111 11111111 11111111 11111111
                     a>>31: 0000000 00000000 00000000 00000001

                     %d:
                        先看符号位      
                            1
                    
                    %u:
                        1



                (3)
                    unsigned char a = -1;
                    a = a >> 31;
                    printf("%d\n",a);
                    printf("%u\n",a);
                    
                    S1:
                        求出-1的补码 
                        |-1|  1: 0000 0001
                              ~: 1111 1110
                              +1:1111 1111

                            >>32:0000 0000

                        %d %u: 0


    (5)赋值运算符 =
        双目运算符 结合性 从右到左
        a = x 
        先把这个x的值求出来,再把整个值赋值给a 
        赋值运算符的左边的操作数必须是一个可写的地址(左值)

            5 = 3;
            2 + 3 = 5;//error
            i++ = 5;//i++是一个表达式 
            i = 6;//正确
        
        赋值表达式:
            由赋值运算符连接的表达式
            赋值表达式的值就是最后赋值给左边变量的那个值
            a = 5   ===> 5

            a = b = 6
            a = (b = 6)

        注意:
            赋值的时候涉及到类型转换,赋值表达式右边的值必须转换成左边变量的类型
            左边变量的类型就是由他是如何定义就决定的,也是赋值表达式的值的类型
            float a = 1;//int ===> float

        
        复合赋值运算符
            赋值运算符和算术运算符 位运算符组成复合赋值运算符

            +=, -+, *= ,/= ,%=.....

            例子:
                i += 6 ===> i = i+6;
                i += 4*5 ===> i = i + (4*5);//

    (6)条件运算符
        ? : 三目运算符 结合性:从右往左

        语法:
            表达式1? 表达式2:表达式3

        求值顺序:
            先计算表达式1的值
                如果表达式1的值为真(非0),则整个表达式的值就是表达式2的值
                如果表达式1的值为假(0),则整个表达式的值就是表达式3的值

        例子:
            int a = 5>4? 3:2;
            a==> 3

    (7)逗号运算符 ,
        双目运算符,结合性从左往右

        语法:
            表达式1,表达式2
        求值:
            先求表达式1的值,再求表达式2的值,整个逗号表达式的值为表达式2的值

        例子:
            int a = 5;
            int b = 6;
            a = (a=6,a+b)

            a:12

        逗号表达式有一个拓展形式:
            表达式1,表达式2,表达式3,....表达式n
        
        求值顺序:
            先求表达式1的值,再求表达式2的值,....最后求表达式n的值
            整个逗号表达式的值为表达式n的值

    (8)指针运算符
        & 取地址符号
        * 指向符

    (9)求字节运算符 sizeof()
        单目运算符
        用来求一个对象或者是一个类型所占内存空间的字节数

        例子;
            sizeof(int) --> 4
            sizeof(1.0) --> 8 (double)
            sizeof(1.0f) -->   4(float)

            short a:
            sizeof(a+1) --> 4 发生了高精度转换

        如果有一个数据x,那么我要求出他的类型, typeof(x) ----> x的数据类型

    (10)分量运算符
        .
        ->
        引用结构体成员变量
            student.name
            stu->score

    (11)下标运算符 []
        数组用来引用数组元素
            int a[10];
            a[0],....

    (12) 强制类型转换运算符()
        语法:
            (数据类型) 对象

        例子:
            float a = 3.6;
            int b = (int)a; //3

    (13)其他运算符


3.优先级
    当我们计算一个表达式的时候,先去看这个表达式的运算符的优先级
    还要去看是有惰性运算,最后才看结合性

    初级运算符((),[],->,.) > 单目运算符 > 算术运算符(先乘除后加减) > 关系运算符 
    > 逻辑运算符(不包括 ! ) > 条件运算符 > 赋值运算符 > 逗号运算符 

    优先级      运算符       
      1         []          
                ()          
                .,->        
      ======================
      2         -(负号运算符)
                ~
                ++
                --
                *,&
                !
                (类型)
      =======================
      3         * / %
                + -
      =========================
      5         <<,>>
      =========================
      6         >,>=,<,<=
      =========================
      7         == !=
      =========================
      8         &,|,^,&&,||
      =========================
      9         ?:条件运算符 
      ==========================
      10        赋值运算符 
      ============================
      11        逗号运算符


      编程建议:
        如果你实在记不住这些优先级的东西,我们直接用括号括起来




    练习:
        1)取整型变量x中的第p个bit为开始n个bit
            假设p = 3  n = 4

            x: xxxxxxxx xxxxxxxx xxxxxxxx xabcdxxx
            思路:
                S1:
                想办法先把我们需要取出来bit位移动到最右边(低位)
                x >> 3 ====> x >> p

                S2:
                需要取出指定的bit数
                xxxxxxxx xxxxxxxx xxxxxxxx xxxxabcd
            & b:00000000 00000000 00000000 00001111
            
            1:  00000000 00000000 00000000 00000001
                1 << 4 ====> 1 << n 
                再进行一个-1 就能够得到我们上面b的那个补码形式

                (x >> 3) & ((1<<4) -1)
                
            得到一个
                00000000 00000000 00000000 0000abcd

        2)将整型变量x中的第p个开始的n个bit进行取反,其他位保持不变 

            假设p = 3  n = 4

            初始二进制序列:
                11111111 11111111 11111111 1 0000 111
              ^ 00000000 00000000 00000000 0 1111 000
              ==============================================
               b:  00000000 00000000 00000000 00001111  =>  1<<4 - 1 
                    b << 3 ==>
                   00000000 00000000 00000000 01111000

              ========================================

            结果:11111111 11111111 11111111 1 1111 111

                x ^ (((1<<4)-1)<<3)

                x ^ (((1<<n)-1)<<p)

            异或:
                x ^ 0 = x 
                x ^ 1 = ~x

    总结:
        1.在C语言中,如果想表示一个2的n次幂的数:2^n
            有两种方法:
                直接计算法:
                    把这个数算出来

                二进制序列位移法:
                    需要求的是多少次幂的
                    我们就直接把1左移多少位
                    1<<n

        2.做这中题目的时候,通常一步到位是比较难得
            先把初始二进制序列和结果二进制序列的关系找到
            在根据他们的联系 一步一步的转化过去

        3.记得加括号!!!
            





        

        
        

 



                











