0.问题的引入
    int a;//(变量地址,数据类型,变量名)

    a = 1024;//左值,是把数据写入到变量的地址中去
    int b = a;//右值,从变量的地址中取出这个值

    变量有左值和右值
    对一个变量的访问,只有两种情况:
        读:从变量的地址中取出这个变量的值
        写:把一个值写入到变量的地址中去

    由此可知:当我们知道了一个变量的地址的时候,是不是就可以通过这个变量的地址去访问
            这个变量?   可以
            如何通过地址访问变量?
                指针

    对象的访问方式有两种
        1)直接访问
            直接通过变量名访问
            a = 1024;
            b = a;

            缺陷?
            作用域的限制

            int f()
            {
                static int a;
            }

            main()
            {
                //能访问这个a吗?
            }

        2)间接访问
            通过对象的地址去访问-->指针
            高效,不受作用域的限制


1.什么是指针?
    地址:分配给每个对象的内存单元都有一个编号,这个编号就是我们所说的地址
        存储器的地址是按照字节来编号的

    在C语言中,指针和地址差不多,你可以认为指针就是一个地址编号
        只不过,指针是一个变量的首地址,我们才叫做指针


2.指针变量 
    指针变量也是一个变量,但是它不是普通的变量
    指针变量是保存一个对象的地址
        间接访问:
            通过对象的地址去访问这个对象
            那么在访问之前是不是得要把这个地址记录下来

    语法:
        指向类型 *指针变量名 { = 初值};

        "指向类型": 
            假设一个变量p保存了a的地址,
            那么我们就说这个p指向a 
            就是指针保存的地址是哪种类型变量的地址

        例子:
            int a;//假设现在需要用一个变量p来保存a的地址

            typeof(a) *p;
            ===>
            int * p;//这个p就是可以用来保存a的地址的变量

3.指针相关的运算符
    1)&(取地址符):    单目运算符
        &对象名:
            取某个C语言对象(变量,数组,函数..)的地址
            要注意的是.有一些对象的名字本身就是代表地址

        例子:
            &x  ===> x的地址 
            int a;
            scanf("%d",&a);
            int *p = &a;

        注意：
            (1)上面这两种方法获取地址都是有类型的

            (2)在32位的处理器里面,地址都是32位的(4字节),所以我们分配的指针变量的
                空间都是32位的
                所以我们之前讲过一个 void*(所有类型的指针)
                因为指针强制转换也不会失真
                (64位机器是8个字节)


                例子:
                    int *p;
                    char *s;
                    s = (char *)p;
                    sizeof(p);          ====> 8/4
                    sizeof(s);          ====> 8/4


            重点:
                指针变量的类型,只决定了指针变量的变化和直接地址变化的倍率


                例子:
                    int a = 5;  //假设a的首地址位0x1000
                    int *p;
                    char *q;
                    p = &a;
                    q = (char *)&a;

                    printf("%p\n",p);//0x1000
                    printf("%p\n",p+1);//0x1004
                    printf("%p\n",q);//0x1000
                    printf("%p\n",q+1);//0x1001

                    p+1:p指向的是int类型的空间,+1之后,会指向下一个int类型的空间
                        地址加了四个字节
                    
                    q+1:q指向的是char类型的空间,+1之后,会指向下一个char类型的空间
                        地址加了一个字节

            结论:
                指针做加减
                p+i (p表示指针,i表示整数)
                    指针和整数做加减运算的时候,不是简单的数值加减
                    而是加减i个指向单元的长度

                    q-1:    -1
                    q+3:    +3
                    p-1:    -4
                    p+3:    +12

            注意:
                指针和指针相加,是毫无意义的
                    int *p = &a;
                    int *q = &b;
                    p+q 
    
    2)*(指向运算符):        单目运算符 
        *地址   <=>   地址对应的那个变量
        变量有左值和右值

            int a = 5;
            *(&a)  <=>  a 
            b = a;
            b = *(&)a

        *和&可以直接约掉

        例子:
            &*&*&a ==> &a 


        
        代码分析:
            int a = 5;
            //用一个变量p来保存a的地址
                指向类型 *变量名;

            typeof(a) * p;
            int *p;

            //我需要把a的地址赋值给p

            p = &a;//此时p是代表变量p的 地址 , 左值

            //变量p的右值是什么?
                a的地址

            既然p保存了a的地址,那么如何通过p去访问a呢?
                把1024的值赋给a 
                a的值有赋给b

                a = 1024;

                p = &a;
                ==>
                *p => *(&)a => a
                *p = 1024;//把1024的值赋给a

                b = a;
                b = *p;


4.野指针和空指针
    1)野指针 
        是指向一个未知地方的指针  undefine

        例子:
            int *p;
                //定义了一个指针,
                //.系统定义变量的时候,如果你不进行赋值
                    那么系统会自动给它一个值
                    这个值 undefine 
            //p指向了一个未知 不确定的地方   p是一个野指针

        使用野指针有没有bug?
            有!!

        *p => *未知地址 ===> 这个地址上的值也是未知的
        如果这个未知地址你不能访问，
        ==>段错误 核心已转储:非法访问了内存

        使用野指针,危害是非常大的(这个bug很难找)
            所以我们使用指针的时候一定要给一个确定的值


    2)空指针
        指向不存在的地址的指针
        不存在:NULL

        例子:
            int *p = NULL;
            //p就是一个空指针

        使用空指针也是有段错误的
        NULL这个地址是不存在,所以它也不能被访问
            使用NULL一定有段错误


    编程建议:
        野指针的危害是很大的,所以大家在使用指针的时候,
        一开始一定要初始化,实在不知道初始化为啥的时候,
        那么我们就让他指向NULL,但是在后面记得要赋值
        (在访问它之前,一定要赋值)


    练习:
        请大家帮我实现一个函数
        xxxx 
      

        功能:   
            交换两个数的值

        xxxx()
        {
            int t;
            t = a;
            a = b;
            b = t;
            //受作用域的限制,这个肯定不行
        }

        xxxx(int x,int y)
        {
            int t;
            t = x;
            x = y;
            y = t;
            //x,y是形参,main函数调用他的时候,只是把值传过来
                这里改变的其实是
                 x和y的值,不影响a和b的值
        }

        间接访问:
            直接把地址传过去

        xxxx(int *x,int *y)
        {
            int t;
            t = *y;
            *y = *x;
            *x = t;
        }//正确的

        
        int main()
        {
            int a = 5;
            int b = 6;
            xxxx();
            //a - > 6   b -> 5
        } 


        在一个函数里面,如果想要访问函数外部且作用域不在该函数的对象
        只能通过间接访问,也就是指针

        通过传递一个指针的方式把地址传过来,再修改地址上的值
        这个对象的值就发生了改变


5.数组和指针
    数组元素和普通变量是一样的,也有左值和右值
    数组元素的地址是连续的

    数组名可以代表数组第一个元素的地址(数组首地址)

    例子;
        int a[10] = {1,2,3,4,5,6,7,8,9,10};

            假设我要定义一个指针变量p,来保存元素a[0]的地址 
            该如何定义?
                指向类型 * 指针变量名;

                typeof(a[0]) --- > int 

                int *p;
                p = &a[0];

                *p == *&a[0] == a[0]

            p保存了a[0]的地址

                a[1]的地址  ===> &a[0] + 4个字节

            那么我如何用指针p来描述a[1],a[2],a[3]...的地址 

            p  === &a[0]
            p+4 === &a[0] + 4 === &a[1]     ?

            指针做加减的时候,
                p+i(p是一个指针,i是一个整数)
                不是简单的数值加减,加减i个指向单元的长度 

            int *p;
            p = &a[0];
            p指向的是int类型 

            p+1 ===> 在数值上加减 sizeof(int)  = 4

            char * q;
            q + 1 ===> 在数值上加减 sizeof(char) = 1

            ----------------------------------------
            int a[10];
            int *p = &a[0];
                表达式:
                    p+1  ==> &a[0] + 1 ==> &a[1]//这里的1是移动了p指向1个p指向类型的大小
                    p+2  ==> &a[0] + 2 ==> &a[2]
                    ...
                    p+i  ==> &a[0] + i ==> &a[i]

                *(p+i) ==> *(&a[i]) ==> a[i];

        结论:
            *(p+i) => *&a[i] => a[i]


    练习:
        int a[10];//a = &a[0]
        int *p;
        p = &a[0];

        我要把100赋值给a[0],有几种表示方法
        a[0] = 100;
        *p = 100;

        *&a[0] = 100;

        a ===> &a[0] ===> p 
        p[0] = 100;//??
        p[0] ==> *(p + 0) ==> *(&a[0] + 0) ==> a[0]

        *a = 100;
        ...
        ****&&&&a[0] = 100;
        =======================================

        假设 int a[10];
                int *p = &a[2];

            表达式p[2]代表什么?
                p = &a[2];

                p[2] = *(p + 2) = *(&a[2] + 2) = *&a[4] = a[4]

                *(p - 1) = *(&a[2] - 1) = *&a[1] = a[1]


            在C语言中,当p是一个指针的时候
                p[i] == *(p+i)  //i >= 0

                在有些特殊情况的时候,p可以进行减法的


6.数组名和指针
    数组名是一个指针常量,是指针的话有会有一个类型?
        数组名是什么类型?
            由数组元素的类型决定,数组名的这个类型
            指针的类型决定了它做加减的时候移动单位长度

    
    数组名就是一个永远指向数组第一个元素的地址的指针
        而且它既可以做数组名使用,又可以作为指针使用
        当数组名做指针,他的值就是第一个元素的地址


    假设x是一个数组
        把x当做一个指针用
            x ---> &x[0]


    例子:
        int a[10];
        //定义了一个指针p,来保存a[0]的地址 

        int * p = &a[0];

        p的类型是什么?
            typeof(p) ----> int *
        
        typeof(&a[0])  --->  int *

        a当指针来使用的时候, ===> &a[0]

        p <===> a 


        int a[10];

        假设我想通过a来访问它里面的元素,能不能访问?
        第一个元素的地址:
            a       --->    &a[0]
        第二个元素地址 
            p+1/a+1 --->    &a[1]


        练习:
            int a[10] = {1,2,3,4,5,6,7,8,9,10};

            printf("a = %p, a + 1 = %p,&a + 1 = %p");

            a:
                当做一个指针来使用,打印是数组首地址(&a[0])

            a+1:
                当做一个指针来使用,打印的是数组第二个元素的地址(&a[1])

            &a+1:
                数组 

        数组名可以当做指针也可以当作一个数组来使用的
            (1)代表整个数组的时候
                typeof(a)  ---> int [10]
                sizeof(a)//求整个数组的字节大小

            (2)在合适的情况下,我们可以把数组名当做指针来使用
                    合适的情况:
                        a + 1;//指针 
                        int *p = a;//指针 
        

            2.int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};

                printf("b = %p b+1 = %p &b[0] + 1 = %p &b+1 = %p");

                请大家判断一下,什么时候b是指针,什么时候b是数组
            温馨提示:二维数组是一个一维数组,只不过每个元素又是一个一维数组
            
                b:指针 
                    b是一个一维数组,每一个元素都是一个一维数组,总共有三个元素
                        int [4] b[3]

                b+1:指针
                    b是&b[0]  b+1 ===> &b[0]+1 ===> &b[1]

                &b[0]+1:
                    同上
                    
                &b+1:数组  
                    b是一个有12个int类型元素的数组
                    &b+1 往后面跳过了12int类型

        总结:
            二维数组的数组名使用的时候,我们把这个二维数组看做一维数组
                只不过这个一维数组的元素类型可能是(int [n])样式的
                那+1的时候,做的运算根据元素类型来决定    



            3.分析以下程序的输出结果
                int a[5] = {1,2,3,4,5}
                int *ptr = (int *)(&a + 1)

                *(a+1):
                    a:指针,代表 &a[0]
                    a+1 ==> &a[0]+1 ==> &a[1]
                    *(a+1) ---> *&a[1] ---> a[1]

                *(ptr-1):  
                    (&a + 1):
                        a代表整个数组
                        &a+1:
                            表示从数组的首地址开始,跳过了5个int类型地址的首地址

                        (int *):强制把指针转换成了一个int *

                        原来:
                            typeof(&a) --->  (int [5]) *

                        现在:
                            ptr --> int * 
                            ptr - 1:往前挪一个int类型大小的地址

                4.                
                    int a[5] = {1,2,3,4,5}
                    int *ptr = (int *)&a + 1


                    *(a+1): 
                            2
                    *(ptr-1):
                            1
                        原来:
                            &a:
                            typeof(&a) --->  int [5] *

                        现在:
                            &a ---> int * 
                            现在它加减变化的倍率是一个int


                5.有一个数组int b[3][4],假如让你定义一个指针变量p,
                    来保存数组的第一个元素 b[0][0]
                    你如何应对?
                        int *p = &b[0][0];

                        数组名不是一个元素吗?
                        int *p = b;???
                        &b[0]:
                            typeof(&b[0]) --->   int [4] *


7.二维数组和指针
    数组名是看做指向数组第一个元素类型的指针,数值上是第一个
    元素的地址
        x数组 x当指针用 x=> &x[0]

    二维数组就是一个一维数组,只不过它的每一个元素又是一个一维数组


    数组和指针的关系
    int a[3][4]
    ------------------------------------------------------------
    表达式(i>=0,j>=0)          类型                含义
    a+i                     int [4] *             第i行的首地址&a[i]

    *(a+i)+j                 int *                第i行第j列那个元素的地址&a[i][j]
        /*
            *(a+i)+j 
            ===> *(&a[0]+i)+j
                *&a[i] + j ==> a[i]+j
            因为在这个数组中,a[i]又是一个一维数组
            所以我们可以把a[i]看做它这个数组的首元素地址
            a[i] ==> &a[i][0]

            &a[i][0]的类型是啥呢?
                typeof(&a[i][0])   =>   int *
            所以 
                a[i]+j ===> &a[i][0]+j ===> &a[i][j]
        */


    *(*(a+i)+j)             int                    第i行第j列的那个元素 a[i][j]

    ==================================================================================
    表达式(i>=0,j>=0)        表达式的含义                   表达式的值
        a                    代表整个数组 
                                sizeof(a)
                                typeof(a)
                                &a 
                        指针,数组第一个元素的首地址         数组第一个元素的首地址&a[0]

        
        a[0]             代表整个数组(第一个元素又是一个数组)
                                sizeof(a[0])
                                typeof(a[0])
                                &a[0]
                         指针,                            数组第一行第一列那个元素的地址
                                                            &a[0][0]

        a[0][0]             数组第一行第一列的那个元素          a[0][0]

    =====================================================================================
        a+1                 a代表指针,&a[0]+1 --> &a[1]     数组第二行的首地址

        &a[1]               同上

        &a+1                a代表整个数组                     指向下一个a类型元素的首地址
                            typeof(a)   int[3][4] *

    ======================================================================================
        a[1]+2              &a[1][0]+2 ==> &a[1][2]              数组元素a[1][2]的地址 
                            a[1]是一个数组名.它这个时候是一个
                            指针,保存的是 &a[1][0]                              

        *(a+1)+2            *(&a[0]+1)+2                        数组元素a[1][2]的地址 
                            => *&a[1] + 2
                                a[1] + 2
                                &a[1][0]+2
                                &a[1][2]

        &a[1][2]                

    ========================================================================================

        *(a[1]+2)            *(&a[1][0]+2)--> *&a[1][2]             a[1][2]

        *(*(a+1)+2)          *(*(&a[0]+1)+2)      
                            *(*(&a[1])+2)
                            ==>*(a[1]+2)                            a[1][2]

        a[1][2]


8.常量指针和指针常量
    常量指针:
        指针
        const int *p  / int const *p
        
        int a = 10;
        int *p = &a;
        *p ===> a;
        这个时候,指针指向了一个常量,我们不能够通过p去修改它指向的对象的值\
        但是我们可以修改指针的指向
        cosnt修饰的是(*p)
            *p一般是指向那个地址上的对象,这个对象我们不能去更改
            但是我可以换个对象去指向

    指针常量:
        指针 
        int *const p;
        cosnt修饰的是一个指针常量p
            p一般是保存了一个地址,这个时候我们的指针,它保存的地址不可以更改了
            数组名就是一个指针常量

            前面我们用数组名进行 a+1 a+2的时候
                这只是一个表达式,并没有改变a的值,这个是OK的
                a++ ===> a = a+1 //改变了指针的值,错误!!! 


9.指针数组和数组指针
    例子:
        int a[4];//定义了一个有四个int类型的数组元素

        能不能定义一个指针来保存a的地址呢?

            只有你有地址,我们就能保存你的地址

        假设是定义一个指针变量
        p = &a;

        p的类型是啥呢?
            指针的类型由它指向那个对象的类型来决定

            typeof(&a)  int [4] *
            现在我要定义一个int[4]类型的指针
            int [4] *p; ===> int  (*p)[4];

            这就是一个数组指针


    (1)数组指针:
        是一个指针,指向一个数组
        int (*p)[4];//括号是和指针括起来的 int [4] *p;

        p是一个指针,指向一个int[4]的类型 
        p+1:加4个int 数值上加了16

        char (*q)[4];
        q+1:加4个char 数值上加了4 



    (2)指针数组:
        是一个数组,里面每个元素都是指针
        
        int * a[4];
        //定义了一个数组a,里面的每个元素都是int *类型 

        a就是一个指针数组
        


作业:
    1.分析以下程序的输出结果
        int a[10] = {1,2,3,4,5,6,7,8,9,10};
        printf("a = %p,a+1 = %p,&a+1 = %p",a,a+1,&a+1);


    2.分析以下程序的输出结果
        int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
        int *p = &b[2][3];
        printf("%d %d %d",*(p-2),*(*(b+2)+1),*(b[2]+3));



10.指针变量作为函数的参数
    C语言中的函数参数传递是"值传递"
        形参 = 实参的值(把实参的值传递给形参)

    所以指针变量作为函数的参数的时候,
        其实是把指针所指向的地址传递过来
        我们可以通过地址间接访问地址上面的对象
    
    例子:
        xxxx(int *x,int *y)
        {
            int t;
            t = *y;
            *y = *x;
            *x = t;
        }//正确的

        
        int main()
        {
            int a = 5;
            int b = 6;
            xxxx();
            //a - > 6   b -> 5
        } 


11.数组做为函数的参数
    (数组元素类型 数组名[],数组元素个数)

    因为参数的传递是值传递

    例子:
        func()
        {

        }

        int a[10];

        func(int a[],int 10);

        那么我们可不可以这么来设计?

    (1)一维数组作为函数的参数
        (数组元素类型 数组名[],数组元素个数)

        int a[10];
        func(int p[],int n)
        {
            p[i]  =>  a[i];
        }

        func(a,10);
        //因为实参和形参的类型是一样的
        //所以我们可以
        typeof(a) ==> 把a看做指针,数组首元素地址
        ===> typeof(&a) --->    int *

        因此,上面那个函数的参数列表可以改写以下形式
        func(int *x,int n)
        {
                       
        }

        func(a,10);//a===> &a[0]  10 ==> int 

        验证 x[i] <==> a[i]?
        //int *x = &a[0];

        x = &a[0];

        //x也是一个数组,x也满足数组名等于数组首元素地址,

        所以 &x[0] <====> x <====> &a[0]

        又因为
        x[i] => *(&x[0]+i) 
        a[i] => *(&a[0]+i)
            
        所以, x[i] == a[i]


        所以以后我们使用一维数组作为函数的参数可以这样子

        void func(数组元素的类型 * 数组名,数组元素的个数);

        "数组元素的类型 *":是一个指针,把要传入的数组首元素地址传进来

        调用函数和以前一样

    (2)二维数组作为函数的参数
        首先,二维数组就是一个一维数组 

        a.
            int a[3][4];

            function(int b[][4],int n)
            {
                //...
            }

            function(a,3);

        b.把二维数组看做一维数组
            int [4] a[3];//数组有三个元素,每个元素的类型是int [4];

            func(int [4] *b,int n)

            ====>
            func(int (*b)[4],int n);//*和b要括起来呢是因为b是一个指针

    
    练习,写一个函数用来求一个一维数组的最大值,用新的传参方法
                {
                    p[i];//                   
                }

                int sum(int *p,int n)
                {
                    int temp = *p;
                    for (int i = 0; i < n; i++) 
                    {
                        if (*(p + i) > temp) 
                            temp = *(p + i);
                    }
                    return temp;
                }


12.字符和指针
    (1)字符数组
        什么是字符数组?
            一个数组里面,它所有的元素都是字符
            例子:
                char c[10];

            char ch[3];//定义了一个有3个char类型元素的数组ch
            for(i = 0;i < 3;i++)
            {
                scanf("%c",&ch[i]);
            }

            注意:
                上面这个输入的时候,%c使用的时候会有一个问题
                就是我们回车 换行它都算是一个字符
                例如:
                    输入a回车b回车c回车
                    实际上在我们输入第二个回车的时候就结束了
                    ch[0] = 'a';
                    ch[1] = '\n';
                    ch[2] = 'b';

            如何解决这个问题?
                在输入的后面加一个getchar()
                getchar()在这里的作用,吸收了回车还有空格

            '\0'

    
    (2)字符串
        字符:
            ASCII码
            char类型
        
        字符串:是一串(0个或者多个)字符 

        在C语言中,压根就没有字符串这个类型,C语言中的字符串是通过char *(字符型指针)来实现的
        C语言的字符串,是用""(双引号)引起来的一串字符,并且字符串后面默认加一个'\0'(ASCII码为0)
        ,我们一般把'\0'叫做字符串终止符

        一般我们只需要保存字符串的首地址即可,因为我们可以通过首地址一个一个往下找(指针做加减),直到
        遇到了'\0'就结束,那么这段空间内的内容都是我们字符串的内容

        字符串:在一段连续的地址上依次存放每个字符
        
        ==============================================================
        字符串和字符数组的区别
            定义:
                字符数组: char a[5] = {a,b,c,d,e};
                字符串: char *s = "abcde"
                    sizeof(a) ==> 5
                    sizeof(s) ==> 6
                    区别:字符数组定义的时候,有时候需要我们自己加'\0'
                        字符串的大小,比你能看得到的数量+1,它后自动带一个'\0'

            输出:
                一般字符数组是一个一个字符的输出 %c + 循环输出
                字符串的格式化输出是%s,碰到'\0'停止输出
        ================================================================

        例子;

            char *p = "12345";//p是一个指针,是指向一个char类型,而不是一堆char类型
                编译器在编译的时候,会把"12345"的首地址赋值给 p 
                也就是把'1'的地址赋值给p

                p = & '1'

                typeof(& '1') ===>  char *

            ""引起来的字符串是个啥类型?
            typeof("12345") --> const char * //字符串常量

            实现字符串的时候根据我们昨天的常量指针和指针常量可知
            实现字符串的指针是一个常量指针,它上面的内容是不可以修改的,但是我可以指向别的地方

            char *p = "abcde";
            *p = 'A';//p保存的是'a'的地址,把'a' - > 'A'
            //这种做法是绝对的错误的,因为 "abcde" 保存在 .rodata区域(只读)

            *(p+2) = 'C';//还是在这个字符串里面,还是错误
                p[2];//把字符串看做一个字符数组(并不是),表示字符串第三个元素
                    p + 1 -> & 'b'
                    p + 2 -> & 'c'
            
            p = "12345";//把p指向了一个新的地方,
                        //p是一个指针,虽然它指向的内容不可以修改,但是它可以指向别的地方


            char s[] = {"12345"};//可以的,定义了一个数组,数组有6个元素
            ===>
            char s[] = {'1','2','3','4','5','\0'};

            这个时候,数组里面的内容可以修改吗?
                可以的,
                    数组s是一个全局变量,保存.data区域
                    数组s是一个局部变量,保存在栈空间
                        无论保存在哪,都可以修改
                s[1] = 'A';
                *(s+2) = 'C';

                s = "abcde";//s是数组的首地址.它永远都是指针数组首地址,指向别的地方,肯定是有问题的



            总结:            
                实现字符串不可以修改里面的内容的
                    char * s = "123";//这是一个字符串
                
                用字符串给数组初始化,我们是可以修改的
                    char s[] = {"123"};//这个是一个数组
                    char s[] = "abcde";

        练习:
            给你一个字符串(给第一个字符的首地址),试着来求一下我们字符串的长度
            实现一个函数来求
            字符串的长度:
                指该字符串中除了'\0'之外,字符的个数

                int mystrlen(char *p)
                {
                    int num = 0;
                    while(*p)//只要*p不是 '\0',就会继续进入循环
                    {
                        num++;
                        p++;//每次把指针向后移动一个,字符串 
                    }
                } 

13.几个常用的字符串处理的函数
    "string.h"
    我们系统已经给我们写好了几个用来处理字符串相关的函数

        在linux里面,有一个手册 man 
        可以通过输入指令
        man 你要查询的内容

    (1)strlen
        NAME
            strlen - calculate the length of a string
                        计算一个字符串的长度
        SYNOPSIS
            #include <string.h>
                //所需要包含的头文件
            size_t strlen(const char *s);
            参数列表:
                const char *s 传入字符串

            返回值:
                size_t:返回一个整数
        
            strlen用来计算s指向的字符串的长度

        例子:
            printf("%的\n",strlen("abc\0123"));
                    3:error
                    8:error
                    4:error
                    'a'
                    'b'
                    'c'
                    '\012':这个字符的ASCII码为八进制的012
                    '3'
                    '\0'

                    5:right


    (2)strcpy/strncpy
        NAME
            strcpy, strncpy - copy a string
                复制字符串
        SYNOPSIS
            #include <string.h>

            char *strcpy(char *dest, const char *src);

            参数列表:
                dest:目标空间
                src:源字符串

            功能:把src指向的那个字符串拷贝到dest所在的空间中去,从首地址开始复制

            返回值:
                成功返回拷贝后的字符串的首地址
                失败返回NULL


        例子:
            char *p = "12345";
            char *s = "abcde";

            strcpy(p,s);
            //把s拷贝到p的空间中,前提是p的空间可写,
                p是可写的吗?
                p是只读的,内存的非法访问


            strcpy 有一个巨大的bug
                没哟考虑到dest目标空间的大小问题,内存的越界访问


            char s1[8];
            char s2[8] = {"ABCDEFG"};
                //有些编译器,在分配内存的时候,一般是连续的
                    s1和s2有可能是连续的地址

            strcpy(s1,"123456789");
            printf("%s\n",s1);  //123456789
            printf("%s\n",s2);  //9

                如果分配的地址是连续的话,那么可能会出现需要拷贝的字符串过长
                把后面数据覆盖了

        如何解决这个问题?
            要是能够决定每次拷贝多少个字符就好了
            char *strncpy(char *dest, const char *src, size_t n);
                strncpy的功能和strcpy功能类似,只不过strncpy最多拷贝
                src前面的n个字符.
                到底它拷贝多少个字符?
                (1)还没拷贝足够多的字符的时候,就碰到了'\0',拷贝结束('\0'也会被拷贝)
                (2)就是刚好拷贝n个字符,但是不会自动添加'\0',除非第n个字符刚好就是终止符'\0'

    (3)strcmp
        NAME
        strcmp, strncmp - compare two strings
                比较两个字符串
        SYNOPSIS
            #include <string.h>

            int strcmp(const char *s1, const char *s2);
            功能:比较两个字符串的大小,看两个字符串是否相等,其实就是比较字符的ASCII码
                直到遇到'\0'终止

                s1:"123456"
                s2:"1234";

                返回值:
                    S1 > S2  :返回一个大于0的数 
                    s1 == s2 :s1和s2相等
                    s1 < s2  :返回一个小于0的数

            例子:
                int m = strcmp("123","ABC");        // m<0
                int m = strcmp("123","123\0ABC");   // m = 0
                int m = strcmp("1234","123");       // m>0


            int strncmp(const char *s1, const char *s2, size_t n);
                //跟上面那个类似,用来比较前n个字符是否相等


    (4)strcat/strncat
        NAME
       strcat, strncat - concatenate two strings
                    连接字符串
        SYNOPSIS
            #include <string.h>

            char *strcat(char *dest, const char *src);
                用来把src指向的字符串,连接到dest的末尾去

            strcat也有一个bug
                    空间太小了,链接的字符串超出了范围
            char *strncat(char *dest, const char *src, size_t n);
                用来把src指向的字符串,最多连接n个到dest后面
                    (1)遇到'\0'自动停止
                    (2)就算没有遇到'\0',但是已经复制了n个了,也会停止,也不会补'\0';


        例子：
            char s2[12];
            char *p = "abcde";

            strcat(s2,p);

            abcde:error

            打印s2:答案是一个未知的,因为s2没有赋初值 undefine


14.函数指针
    (1)什么是函数指针?
        是一个指针,这个指针保存的是函数的地址

    
    (2)如何定义一个函数指针?
        指针的定义
            指向的类型 * 指针变量名{ = 初值};

        例子:
            int sum(int a,int b)
            {

            }

        sum的类型 *p;

        typeof(sum)

        如何描述一个函数的类型?
            函数有三要素:
                返回值 函数名(参数列表)
            
            typeof(sum)
                ==>  int (int,int) 

            函数指针就定义好了
                int (int ,int) *p;
                ===>
                int *p(int,int);

                出现歧义:
                    上面这个像一个返回值为int * 类型,名字叫p的函数
                    为了避免歧义,把*和p括起来

                int (*p) (int, int);

        函数指针的定义:
            指向函数的返回值类型 (*函数指针变量名)(指向函数的参数列表类型)

    (3)如何给函数指针赋值
        p = 函数的地址
        如何获取函数的地址?
            &函数名 
            //
            函数名 

        例子:
            p = &sum;
            p = sum;

    (4)如何去调用函数指针?
        sum(1,2);

        p = &sum; 
        *p === *&sum === sum

        (*p)(1,2);
        
        // 
        p = sum;

        p(1,2);

        函数指针调用函数的格式:
            (*函数指针)(函数的实参列表)

            或者

            函数指针(函数的实参列表)

    练习:
        有一个函数,用来求一个一维数组的最大值

        int find_max(int *a,int n)
        {
            int max = a[0];
            int i;
            for(i = 0;i < n;i++)
            {
                if(a[i] > max)
                {
                    max = a[i];
                }
            }
            return max;
        }

        请大家帮忙定义一个函数指针p,来指向find_max
        并且通过p来调用它

        指向函数的返回值类型 (*函数指针变量名)(指向函数的参数列表类型)

        int (*p) = (int *,int);//p就是指向函数的指针
        p = &find_max;
        int a[10] = {1,2,3,4,5,6,7,8,9,10};
        p(a,10);

        我们已经知道了函数名,那么为什么还要定义这个指针呢?

    (5)函数指针的作用
        主要是用来实现 回调函数 的
            callback 

        回调:
            现在不调用,回过头来再用

        回调函数:
            可以被当做参数传递的函数

            用户可以把一个函数的指针当做参数传递给另外一个函数
            以便于该函数在处理相关的事件的时候,可以灵活使用多种方法

            "中断机制"


15.二级指针和多级指针
    int a = 5;
    定义一个指针来保存a的地址
    int *p = &a;

    p是一个指针变量,它本身是不是也有一个地址?
    所以我们又可以定义一个指针来保存p的地址

    typeof(p) * p2 = &p;

    typeof(p) ==> int *

    int **p2 = &p;//这个时候p2就是一个二级指针
        //不要被这个**个迷惑了,不管是多少级的指针,指针就是用来保存地址的,


    练习:
        有以下的代码
        int a = 5;
        int *p = &a;

        定义一个指针变量p2来保存p的地址
        并且通过p2来改变a的值

        int **p2 = &p;
        
        p2 === > &p 
        p ====> &a 
        *p2 ===> *&p === > p 
        *p ===> a 

        **p2 ===> a 

        **p2 = 6;

        现在我们发现,好像我只要知道一个地址,我们就不需要对象的名字,也可以访问
        只有知道一块地址,好像有没有对象名和它对应,不是很重要,也可以修改上面的内容
        我们只要知道他的地址,就没有问题


15.动态内存/匿名内存
    malloc/realloc/calloc
        内存分配
        是从一个叫做堆空间的地方,给我们分配内存,而且,从堆空间分配的内存
            一旦分配,它就一直存在,除非手动释放或者程序结束了,才会回收

    free
        释放分配的空间
    


    NAME
       malloc, free, calloc, realloc - allocate and free dynamic memory

    SYNOPSIS
        #include <stdlib.h>
            //头文件

        1)void *malloc(size_t size);
            malloc用来分配一个size大小(以字节为单位)的内存空间,并且它会把
            分配的空间的首地址返回
            首地址:
                某种类型的指针
                    int *
                    char *
                    int [4] *

            malloc返回的指针,只是一个首地址
            malloc分配的空间,千万要记得释放的

            参数列表:
                size:表示分配多少个字节
                返回值:
                    成功返回分配的内存空间的首地址
                    失败返回一个NULL            

        2)void *calloc(size_t nmemb, size_t size);
            calloc作用类似于malloc,也是从堆空间分配一段连续的内存空间
            只不过它多了一个参数,类似于用数组的方式分配内存
            参数列表:
                nmemb:表示分配多少个元素
                size:表示每个元素占多少个字节
            返回值:
                成功返回分配的内存空间的首地址
                失败返回NULL

            calloc分配的内存大小:   nmemb * size 

            calloc分配的空间,他会自动置0
            malloc不会 

            calloc(n,size)  <===> malloc(n * size)

        上面这两个都是你没有空间,给你申请新的空间
        
        3)void *realloc(void *ptr, size_t size);

            repeat allocate:
                realloc把原来的ptr指向的空间(由malloc/calloc返回的动态空间),
                扩展成size大小

            参数列表:
                ptr:指向一个空间,这个空间必须是堆空间
                size:
                    1.size>原来的大小
                        realloc把ptr指向的内存,扩大到size大小,
                        原来内存上的内容不变,后面新增的空间也不会
                        初始化
                    
                    2.size = 0 
                        realloc(ptr,0) ===> free(ptr);

                    3.szie < 原来的大小
                        这种情况,是calloc的作者都没有想到的
                        结果是一个undefine(一切皆有可能)

            返回值:
                成功返回扩建后的内存首地址
                失败返回一个NULL 

        4)void free(void *ptr);
            free只能用来释放堆空间里面的内容
            ptr保存的一定是上面那三个函数的返回值

            int a;
            free(&a);


    练习:
        1.把下面东西,改成用malloc来分配空间
            int n;
            scanf("%d",n);

            int a[n];

            //定义了一个一维数组,里面有n个int类型的元素

            ---------------------------------------

            int n;
            scanf("%d",n);

            int *a = NULL;//定义一个指针,待会来保存一块连续内存的首地址

            //a = malloc(n*sizeof(int));
            //a指向了一块连续内存空间,大小是n*sizeof(int)

            a = calloc(n,sizeof(int));
            //现在a指向这块连续的内存空间全部初始化为0

            int i;
            for(i = 0;i < n;i++)
            {
                scanf("%d",a+i);
            }

        2.小明,自认为自己是一个很牛逼的程序员了,经常写代码到大半夜,
            下面是它的一个代码片段,大家看看有没有问题

            void f()
            {
                char *p = malloc(100);
                //定义一个指针保存malloc的返回值
                //上面这块内存又对应的变量名和它相关联?
                //只能通过p来访问,突然p又指向了别的地方,
                //只要程序还在运行,这块内存不会被释放的
                        "匿名内存" 无法访问了

                p = "12345";
                //指针又指向别的一个地方
            }


            "垃圾内存/内存泄漏"


            java垃圾回收机制
                为每个动态申请的内存进行计数


            申请了的内存,记得要释放掉

16.main函数的参数问题
    main函数的语法:
        int main(int argc,char * argv[])
        {

        }
        参数列表:
            argc:是一个int类型,代表命令行的参数个数(./a.out 就是第一个命令参数)

            char* argv[]:数组,字符串数组 
                argv[0]:保存的是程序第一个参数 比如:./xxx ./a.out
                        保存的是启动改程序的程序名
                        所以命令行参数个数至少为1
                argv[1]:保存的是程序第二个参数 
                ...

        例子:
            int main(int argc,char * argv[])
            {
                int i = 0;
                printf("argc = %d\n",argc);

                for(i = 0;i < argc;i++)
                {
                    printf("argv[i] = %s\n",i,argv[i]);
                }
            }

        在linux下,程序运行的时候,允许带参数,只不过这些参数都是字符串
        所以我们知道了 main函数带两个参数的

        一个参数是命令的个数 int argc
        一个参数是保存了我们每一个字符串命令 char * argv[]

        并且系统在调用main函数的时候,就会自动的把值传给形参

        main函数的返回值
            int 
            一般的来说main函数的返回值由我们自己觉得
            一般的返回一个0的话,就表示程序正常运行

        main函数的返回值我们又看不到,那么还要他有什么意义呢?
            main函数的返回值,作为整个进程退出的一个返回值

        
        练习:
            通过main函数传参,来实现一个加法
            提示;
                字符串转数字,有一个函数
                atoi("123") --> 123(int)
            int main(int argc,char *argv[])
            {
                int a = atoi(argv[1]);
                int b = atoi(argv[2]);
                int c = a+b;
                printf("%d\n",c);
            }
            ./a.out 111 222

===========================================================================
    指针的内容和前面的内容都有关系
        因为指针是保存对象的地址的

    
    1.指针的定义
        指向的类型 * 指针变量名;
        指向的类型:基本类型,数组,函数,指针类型

    2.两个运算符
        *指向运算符 
        &取地址运算符

        int *p = &a;====> p = &a;

    3.指针做加减
        不是数值上的加减,是指针变化的倍率
    
    4.数组和指针 
        数组名是一个指针常量,永远指向数组首元素的地址
        (二维数组当作一维数组来)

        数组名有两个含义的
            整个数组/指针 

        a+1;
        &a[0] + i === > &a[i];

    5.指针常量和常量指针
        定义上面有的
        看关键字const修饰的是谁

    6.数组指针和指针数组
        一个是指针,指向一个数组
        一个是数组,里面全是指针

    7.指针作函数的参数 
        "值传递"

    8.字符和指针 
        字符数组和字符串 

        字符串数组:数组元素全是指针,只不过这些指针都是用来实现字符串的

        常用的那几个字符串相关的函数

    9.指针和函数
        "回调函数"

    10.动态内存/匿名内存 
        数据结构大量会使用
    
    11.main函数 
        带参数的


作业:
    1.请大家自己来实现以下my_strcpy/my_strcmp/my_strcat
        自己写代码实现 strcat strcpy strcmp

    2.字符串的循环左移,请大家编写一个函数实现以下的功能
        输入一个不超过100个字符长度的字符串
        输入一个非负整数N
        比如:
            输入 
                hello world
                3
            结果:
                lo worldhel

    3.反转字符串
        编写一个函数,作用是把字符串反转过来,以字符数组的形式输入字符串

        输入: char a = ['h','e','l','l','o'];
        输出:   "olleh"

    4.判断一个字符串是否是一个回文串
        输入 "abcddcba"
        输出: true

        输入 "abcdabcd"
        输出: false

    5.实现一个函数叫做strstr
        功能:
            判断一个字符串是否是另外一个字符串的子串

        输入:   "hellowrld" "llow"
                是 
        
        输入:   "helloworld" "lle"
                不是 

    6.在科学计算中,经常会使用超级大的数值,但是我们C语言中,能表示的数值有范围限制
        ,所以请大家设计一个超级计算器
        1111111111111111111111111111111111111111111111111111111111111111111111
     +  11111111111111111111111111111111111111111111111111111111111111111111119
        能计算超大的值
        提示:
            数值用字符串表示

            考虑进位问题



        牛客做做选择题
        力扣看看每日一题
        CSDN和我答疑解惑

































                
        力扣:上面主要是编程题
            从简单题开始做起
            每日一题:
                不会做没关系,可以适当参考评论区大佬

        牛客:
            选择题

        CSDN:
            一些不懂得地方自己去这上面查找一下




    

        



    




            






        


            














        
        


    
        



