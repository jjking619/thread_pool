数据类型
运算符与表达式
分支结构
循环结构
数组
函数
指针(重难点)
结构体
C程序组成

0.问题的引入
    我们所有要处理的数据(视频 图片 音频等文件)
        都是以数字信号(二进制)的形式来保存的
    把8bits称作一个字节,字节是最小的可操作单位

    当计算机保存上面那些数据的时候,我们要对这个内存进行精打细算
    为了避免出现很大的内存保存很小的数据,或者是很小的内存来保存很大的数据

    那如何让操作系统知道这些数据的属性?
        涉及到了数据类型

1.C语言数据类型
    (1)基本类型
        系统分配给基本类型的变量的大小是固定的, C语言已经定义好了的类型,主要用来保存 数

        1)整型
            short 2个字节(16bits)
            unsigned short  0~2^16-1
            (signed) short  -2^15~2^15-1
        
            int 4个字节(32bits)
            unsigned int    0~2^32-1 
            (signed) int    -2^31~2^31-1

            long  
                4个字节     32位机器上
                8个字节     64位机器上
            
            unsigned    无符号
                代表所有的bit位都是数值
            signed      有符号
                可以省略signed,系统会默认是有符号的数
                最高位是符号位
                1   负数
                0   正数

            不同的编译器,同一类型的大小也不一样
            keil    int ---> 2字节 
            ===============================
            当CPU把数据进行运算的时候,它不是直接计算变量的数据
            需要先把数据拷贝到CPU的内部寄存器中(64bits)
            再对寄存器的值进行操作

            当变量的数据小于64位的时候
                无符号的数据寄存器高位补0
                有符号的数据寄存器高位补符号位
        
        2)字符型
            char    1个字节(8bits)
            unsigned char   取值范围0~2^8-1(255)
            (signed) char   取值范围-2^7 ~ 2^7-1

            例子:
                char a = 260;
                printf("%d\n",a);  4

        3)浮点型
            float(单精度)占四个字节(32bits)
            储存方式见图
            最高位是符号位占1bit,1就是负数,0就是正数
                30-23bit是指数段,占8bits,原来的指数加上127才得到了这个二进制数
                22-0bit是尾数段,占23bits

            double(双精度)占8个字节(64bits)
            63位(最高位)为符号位,1是负数,0是正数 
            62-52bit为指数段,占11bits,原来的指数加上1023得到的二进制数
            51-0bit为尾数段,占52bits

        注意:
            在C语言中,整数默认的类型是int,浮点数默认的类型是double
            typeof():用来求一个对象的数据类型
            例子:
                int a;
                typeof(a) ===> int

                typeof(3) ===> int
                typeof(3.1) ===> double

    (2)构造类型
        C语言允许用户自定义类型
        这个自定义类型的大小是由你这个类型决定的

        数组类型:后面会讲
        结构体类型
        枚举类型
        联合体类型(共用体)

    (3)指针类型
        后面会讲的
        带*号多半和指针有关系

    (4)void类型
        空类型,代表在内存中不占内存空间大小

        在C语言中,void有三大作用
        1)void 作为函数的返回值,表示函数不返回任何数据
            例子:
                void main()
                {

                }

        2)void 作为函数的参数列,表示函数不需要任何参数,此时,void可省略
            例子:
                int main()
                {

                }

        3)void*通用指针,在一个操作系统,所有指针类型的内存大小是一样的

        
2.变量和常量
    (1)变量 
        1)什么是变量
            在程序运行的期间,其值可以改变的量,就是变量

                变量实际上是由内存中一块特定的储存空间来保存的,这个储存空间
                里面的值,就是变量的值,这个值是可以改变的

            变量名
                在定义变量的时候,会在内存中分配空间(空间的大小是根据变量的数据类型来决定)
                这个变量名就和这个空间的首地址关联起来了
                操作系统就可以根据变量名访问这个内存地址空间
        
        2)变量的定义语法
            数据类型 变量名;
            数据类型 变量名 = 初始值;

            "数据类型":所有C语言的合法类型都可以
            "变量名":符合C语言的标识符命名规则
                规则:由数字,字母,下划线组成
                    不能以数字开头,只能够以字母或者下划线开头
                    不能和关键字冲突,并且区分大小写
                例子:
                    abc 12a cxk _asd

                    "可读性"
                        变量名要做到"见名知其意"
                        sum 
                        score
                        num
                        booknum===> book_num/BookNum 

        3)变量的访问(读/写)
            a.从变量中去读取值(读)
                实际上是通过变量名找到相应的储存地址,取出该地址上面的值
                这个时候一般变量在( = )的右边,表示该变量的值,称作右值(rvlaue)

            b.往变量中写入值(写)
                实际上是通过变量名找到相应的储存地址,把值写入到该地址上面
                这个时候一般变量是( = )的左边,表示该变量对应的地址,称作左值(lvalue)

            例子:
                int a;
                a = 10;//左值,代表的是变量名a所关联的储存空间地址
                int b = a;//右值,代表的是变量名a所关联的储存空间地址上的值

            我们一般在定义变量的时候就对变量复制,称作初始化
                int abc = 10;
                int abc;
                abc = 10;
                //
                int a[10];
                a[10] = ....;

            如果定义变量的时候不初始化,变量的值是有的,但是是一个不确定的值
            编程建议:
                每次定义变量的时候级的要赋初值

    (2)常量
        1)什么是常量?
            在程序运行期间,他的值是不可以被改变的量,叫做常量
            比如:
                3 4 100 π...

                3 = 5;//error 3是一个常量

        2)整型常量
            (1)二进制常量:由0和1组成 不能够格式化输出
                0000 0010  ===> 十进制的2
            
            (2)八进制常量:以字符0开头,后面接0个或者多个0-7的字符
                格式化输出 %o
                比如:
                    0666 0123 0211345
                    0888//ERROR!!

            (3)十进制常量
                格式化输出 %d 
            
            (4)十六进制常量:以0X或者0x开头,后面接0个或多个0-9 a-f A-F的字符组成的
                格式化输出:%x 
                比如:
                    0xff
                    0x11

            ==========================
            不同进制的转换
                以十进制为中介,先把某一进制转化成十进制,再转化成另外一个进制

                二进制  ====> 八进制    一位八进制对应三位二进制
                000             0
                001             1
                010             2
                        ...
                110             6
                111             7

                二进制  ====>   十六进制 一位十六进制对应四位二进制
                0000            0
                0001            1
                ....
                1001            9
                1010            a/A 
                ...
                1111            f/F
                
            结论:   
                a.任何一种进制转化成十进制都是通过乘权值

                b.任何一种进制转化非十进制,可以考虑先转化成二进制,再转化成另外一个进制
                比如
                    八进制 ===> 十六进制

                    0777 ==> 二进制 111 111 111
                    0001 1111 1111 ==> 十六进制 0x1ff

        3)浮点型常量
            由整数部分,小数点,小数部分,一个E/e,一个可选的带个符号的正数指数加
            一个表示类型的后缀组成的(f/F/l/L)
            f/F:float
            L/l:long double
            
            整数部分:可以省略 
            小数部分:可以省略 
            但是整数和小数不能同时省略

            如:
                float a = 2.3E3;
                        .3E3
                        5E-5;
                
                E5;/会产生歧义,可能定义一个变量就叫做E5

                E/e:科学计数法中表示10的多少次幂
                    E3 ===>  10^3
                    E-5 ====> 10^(-5)

            单精度float 格式化输出%f 
            双精度double 格式化输出%lf 
            (默认输出6位小数)


            printf("%5.2f\n",a);//整个浮点数一共占5位(包括小数点),其中小数部分占2位
                                    向右靠齐,左端补空格
                                    当实际位数大于约定的位数,那么就按照实际位数输出

            printf("%-5.2f\n",a);//整个浮点数一共占5位(包括小数点),其中小数部分占2位
                                    向左靠齐,右端补空格
                                    当实际位数大于约定的位数,那么就按照实际位数输出

        4)字符常量
            字符常量它是由 单引号 引出来的一个或者多个字符的序列,格式化输出是%c           
                'a' '0' '1' 

            在计算机中,保存一个字符,保存的是它的ascii码
             man:手册 可以在上面查看一些函数 ASCII码等等资料

                在终端输入 man ASCII 就能够查看这个ASCII码的对照表
                Oct:八进制 
                Dec:十进制 
                Hex:十六进制 

                Oct   Dec   Hex   Char                        Oct   Dec   Hex   Char
        ────────────────────────────────────────────────────────────────────────
            000   0     00    NUL '\0'                    100   64    40    @
            001   1     01    SOH （标题开始）            101   65    41    A
            002   2     02    STX （本文开始）            102   66    42    B
            003   3     03    ETX （本文结束）            103   67    43    C
            004   4     04    EOT （传输结束）            104   68    44    D
            005   5     05    ENQ （请求）                105   69    45    E
            006   6     06    ACK （确认回应）            106   70    46    F
            007   7     07    BEL '\a' （响铃）           107   71    47    G
            010   8     08    BS  '\b' （退格）           110   72    48    H
            011   9     09    HT  '\t' （水平定位符号）   111   73    49    I
            012   10    0A    LF  '\n' （换行键）         112   74    4A    J
            013   11    0B    VT  '\v' （垂直定位符号）   113   75    4B    K
            014   12    0C    FF  '\f' （换页键）         114   76    4C    L
            015   13    0D    CR  '\r' （Enter 键）       115   77    4D    M
            016   14    0E    SO  （取消变换）            116   78    4E    N

            (1)普通字符:一般的来说,我们能够打印出来的,能够看到的字符就是普通字符
                比如:
                    'a'-'z' '0'-'0' ....

            (2)转义字符:一般不可以打印出来的,没有形状的,有另外一层的含义
                比如:
                    '\n'换行符
                    '\t'制表符
                    '\'反斜杠付
                    ..

                    '\ddd':ddd表示1到3位的八进制,打印效果就是该数字对应的一个ASCii码的字符
                    putchar('\101') ===> 'A' 

                    '\xdd':dd表示1到2位十六进制,打印效果为该数字对应的ASCII对应的字符

                    putchar('\x41') === > 'A'

        例子:
            定义一个字符A,有多少种定义的方式
            char c = 'A';
            char c = 0101;//八进制 
            char c = 65;//十进制 
            char c = 0x41;//十六进制 

            char c = '/101';
            char c = '/x41';   


3.整数的存储问题
    整数是以二进制的补码形式存放在计算机中

    1)正数 
        正数的补码就是其原码本身
        原码:把这个数转化成二进制

        例子:
            char a = 13;
            13的原码 ===> 0000 1101  这个既是13的原码又是13的补码

            int b = 9;
            9的原码 => 00000000 00000000 00000000 00001001

    2)负数
        负数的补码是 其绝对值的原码 取反 加1 得到的

        例子:
            char a = -13
                |-13| => 13: 0000 1101
             取反(0变1 1变0): 1111 0010
                         +1:  1111 0011
                        -13的补码就是 1111 0011

        已知一个负整数的补码,如何去计算这个负整数的十进制数
        补码还原:逆运算
            负数补码 --- -1 ---- 取反 ---- 绝对值的原码 ---- 得到负数


        练习:
            假设是一个char类型的变量
            -2在计算机中如何存放 1111 1110
                |-2| 2: 0000 0010
                   取反: 1111 1101
                   +1:   1111 1110

            254在计算机中如何存放
                1111 1110

            -3如何存放
                |-3| 3:0000 0011
                   取反:1111 1100
                   +1: 1111 1101
            253如何存放
                1111 1101

                ...

        结论:
            一个负整数(-X)会和一个正整数(2^N-X)的储存形式是一样的
            (N代表用多少位来存这个数)


            计算机如何知道你这个数是正数还是负数?
                %d:以有符号的(32位)整数形式进行输出(要看符号位,符号位0就是全部是数值,符号位是1,进行补码还原)
                %u:以无符号的(32位)整数形式进行输出(不需要看符号位,所有的位都是数值)

            总结:
                a.当编译器以有符号(32位)的整型输出的时候(%d),需要考虑补码还原的解读方法,需要看符号位
                b.当编译器以无符号(32位)的整型输出的时候(%u),就没有符号位的概念了
                    直接把所有位当做数值位来转化成十进制输出
                c.当CPU把数据进行运算的时候,是根据内存中的存放形式进行运算的,内存中的存放形式就是补码


        练习:   
            int a = -2;
            printf("%d\n",a);
            printf("%u\n",a);
            S1:-2在计算机中的存储方式
                |-2|    2:00000000 00000000 00000000 00000010
                     取反:11111111 11111111 11111111 11111101
                       +1:11111111 11111111 11111111 11111110
            S2:
            %d:先看符号位,如果符号位是1,需要进行补码还原
                        如果符号位是0,直接根据剩余位数计算权值得到十进制数
                
                    补码还原:
                        -1 ====> 取反 ====> 绝对值 ====> 负数 
                -2
            
            %u:直接根据补码的bit位上的数计算权值得到十进制数
                2^32-2


            char d = -56;
            printf("%d\n",d);
            printf("%u\n",d);

            S1:-56在计算机中的存放方式
                |-56| 56:0011 1000
                     取反:1100 0111
                     +1:  1100 1000    补码形式

            S2:
                %d:  char  ===> int 
                   11111111 11111111 11111111 11001000 

                   补码还原:
                        11111111 11111111 11111111 11001000 
                    -1: 11111111 11111111 11111111 11000111
                    取反:00000000 00000000 00000000 00111000
                        -56

                %u:char  ===> int 
                   11111111 11111111 11111111 11001000 

                   ===> 2^32-56


4.整数之间的赋值问题
    在C语言中,允许各个类型整数之间的互相赋值
        char ===> int
        int  ===> short
        unsigned int ===> int
        ...

    赋值规则:
        1)长的数据类型 -> 短的数据类型
            int -> short
            int -> char 
            低字节全部拷贝,高字节全部舍弃

            例子:
                char a = 260;

                printf("%d\n",a);

        2)短的数据类型 -> 长的数据类型
            char => int 
            short => int
            低字节全部拷贝,高字节分情况:
                如果短的数据是无符号的,高字节全部补0
                如果短的数据是有符号的,高字节全部补符号位

            例子:
                (signed)char => int 
                11001010   ===> 11111111 11111111 11111111 11001010

                unsigned char => int
                11001010   ===> 00000000 00000000 00000000 11001010

                char => int
                01001111   ===> 00000000 00000000 00000000 01001111


    练习:
        1)
            unsigned char d = -56;
            printf("%d\n",d); 200
            printf("%u\n",d); 200

            S1:-56的补码形式
                |-56| 56: 0011 1000
                    取反: 1100 0111
                    +1:   1100 1000

            unsigned char ===> int
            短->长 低字节全部拷贝,高字节看情况
            1100 1000  -> 00000000 00000000 00000000 11001000
            %d:200

            unsigned char ===> unsigned int 
            1100 1000  -> 00000000 00000000 00000000 11001000
            %u:200

        
        2)
            char a = 250;
            char d;
            d = a+8;
            printf("%d\n",d); 2
            printf("%u\n",d); 2

            S1:
                求250在计算机中补码形式
                a:1111 1010

                d = a + 8;
                8 ==> int 
                a ==> int -> char ==> int

                a:1111 1010 ==> 11111111 11111111 11111111 11111010
                         +  8:  00000000 00000000 00000000 00001000(int)
                          a+8:1 00000000 00000000 00000000 00000010

                a+8 ===> d 
                int -> char

                d: 0000 0010

                %d:
                    char -> int
                    符号位为0,高位全部补0
                    00000000 00000000 00000000 00000010
                    符号位为0,是一个正数,直接输出
                    ===> 2
                %u: 
                    char -> unsigned int 
                    符号位为0,高位全部补0
                    00000000 00000000 00000000 00000010
                    按照无符号直接输出
                    ===> 2

        3)
            unsigned char a = 250;
            int d = a+8;
            printf("%d\n",d); 258
            printf("%u\n",d); 258

            S1:先求250的补码形式
                    a:1111 1010

                    a + 8: 
                        unsigned char -> int
            a:1111 1010 -> 00000000 00000000 00000000 11111010
                        8   00000000 00000000 00000000 00001000(int)
                d:    a+8: 00000000 00000000 00000001 00000010(int)   

            %d:先看符号位,符号位为0,是一个正数,直接输出 
                258
            %u:直接输出
                258     

    练习:
        (1)
        short a = 32767
        a = a + 1;
        printf("%d\n",a);
        printf("%u\n",a);
        S1:求a的补码
            a->32767-> 01111111 11111111

            a+1:
                short -> int
                a:00000000 00000000 01111111 11111111
                1:00000000 00000000 00000000 00000001
              a+1:00000000 00000000 10000000 00000000 

            a+1 === > a 
                int -> short
                10000000 00000000  最终a的补码
            
            %d:
                short -> int 
                11111111 11111111 10000000 00000000 补码还原 
            -1  11111111 11111111 01111111 11111111
           取反 00000000 00000000 10000000 00000000     绝对值的补码 
            绝对值是32768
            这个值是 -32768

            %u:
                short -> int 
                11111111 11111111 10000000 00000000

                这个值 2^32-32768
        

        (2)
        unsigned int a = 10;
        int b = -30;
        int w = a+b;
        printf("%d\n",w);
        printf("%u\n",w);  
        判断一下a+b的值 和 w的值是同 一个东西吗
            a+b 等价于 w 吗?
                不等价 a+b的值是unsigned int 类型的
                int + unsigned int ===> unsigned int

                w的值是int类型的


        a的补码:
            00000000 00000000 00000000 00001010
        
        b的补码:
            |-30| 30:00000000 00000000 00000000 00011110 
                取反:11111111 11111111 11111111 11100001
                +1:  11111111 11111111 11111111 11100010

        a+b:int + unsigned int ===> unsigned int
            a:00000000 00000000 00000000 00001010
            b:11111111 11111111 11111111 11100010
          a+b:11111111 11111111 11111111 11101100 (unsigned int)

          w的补码:11111111 11111111 11111111 11101100(int)
          %d:
            符号位为1,是一个负数,补码还原
                11111111 11111111 11111111 11101100
             -1:11111111 11111111 11111111 11101011
            取反:00000000 00000000 00000000 00010100 绝对值的补码
            这个值 -20
          
          %u:
            所有的位都是数值
            2^32-20

        (3)
        unsigned short a = -100;
        int d = a + 8;
        printf("%d\n",d);
        printf("%u\n",d);

        S1:
            求a的补码
            |-100| 100:00000000 01100100
                  取反:11111111 10011011
                  +1:  11111111 10011100

            a+8:
                short -> int
               a:00000000 00000000 11111111 10011100
               8:00000000 00000000 00000000 00001000
             a+8:00000000 00000000 11111111 10100100

            d:00000000 00000000 11111111 10100100

        %d:
            符号为0,是一个正数
                直接输出:
                    65444
        
        %u:
            直接输出 
                    65444


知识回顾:
    1.C语言数据的类型
        四种类型
            基本类型 
                unsigned 和 signed
            剩下三个都是后面详细讲

    2.变量和常量 
        变量:
            变量的定义 
            变量的读写
                左值和右值

        常量:
            常用几种进制之间关系

            字符常量:ASCII码 
                    要记住几个常用的字符的ASCII码
                    '0' ---> 48
                    'A' ---> 65
                    'a' ---> 97
                    ...

            字符串常量

    3.整数的存储问题 
        核心:所有的整数在计算机中都是以补码的形式存在

        %u和%d:无符号/有符号的32位输出(int)

    4.各种类型(整型)之间的赋值问题
        知道 长->短 短->长 的规则










                
