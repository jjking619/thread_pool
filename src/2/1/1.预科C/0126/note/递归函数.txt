0.问题的引入 
    写一个函数来求  当有n个人的时候,来求第1个人的年龄
        总共有8个人,第一个人比第二个人大两岁,第二个人又笔第三个人大两岁
        第三个人又比第四个人大两岁....一直到最后一个人,他说他10岁
    
    四步法:
        确定函数名:
            age 

        确定输入的参数
            有多少个人

        确定返回值 
            要返回的是第一个人的年龄

            int age(int n)

        算法实现:
            int age(int n)

            /*
                第一个人 = 第二个 + 2
                age(1) = age(2) + 2
                第二个 = 第三个 + 2
                age(2) = age(3) + 2
                第三个 = 第四个 + 2
                age(3) = age(4) + 2
                ...
                第n - 1个 = 第n个 + 2

            */

            int age(int n)
            {
                if(n == 1)
                {
                    return 10;
                }
                else
                {
                    return age(n-1)+2;
                }
            }

            递归函数:函数定义的时候调用他自己本身



1.递归函数(重点 难点)
    什么是递归函数?
        函数直接或者间接的调用函数本身
        "自己调用自己"

    什么情况下使用递归?
        解决一个问题的时候,解决的思路又有和问题本身类似的问题,就使用递归

    例子：
        上面那个题目,
            有n个人的时候,求第一个人的年龄
            第一个人年龄 = 第二个人年龄 + 2
            第二个 = 第三个 + 2
            ...
            第n个 = 10


        解决问题的时候,又碰到了和问题类似的问题了,那么就需要递归

        是不是所有的递归问题,C语言都能解决?
            不是的
        C语言能够解决的递归问题,满足两个条件
            (1)问题是一个递归问题
            (2)递归不是无限递归
                适合那种,递归到一定程度时,答案是显而易见的
                "跳出递归的条件"

        C语言是如何支持递归的呢?
            "栈"

    例子:
        1.写一个函数求 n!

            (1)明确任务目标 
                确定函数名 
                    jiec

            (2)确认输入的参数 
                    int n 

            
            (3)完成的返回值
                int jiec(int n)


            (4)函数的具体实现

                求n的阶乘
                n! = n * (n-1)!
                (n-1) = (n-1) * (n-2)!

                ....
                1! = 1
                0! = 1


                int jiec(int n)
                {
                    if(n == 0 || n == 1)
                    {
                        return 1;
                    }
                    else if(n > 1)
                    {
                        return jiec(n-1)*n;//函数在这里先展开,得到明确的值之后,在一步一步返回给值
                    }
                }



        2.用递归的方法求一个一维整型数组的和
            假设数组有n个元素
                S1 = a[0]       
                S2 = a[0] + a[1]      =  S1 + a[1]
                S3 = a[0] + a[1] + a[2] = S2 + a[2]
                ...
                Sn = a[0] +.... a[n-1] = S(n-1) + a[n-1]



            //递归数组求和
            int array_sum(int a[],int n)
            {
                if(n == 1)
                {
                    return a[0];
                }
                else
                {
                    return array_sum(a,n-1) + a[n-1];
                }
            }

    总结:
        1.递归不是C语言的语言特性,是数学上的一种思维,帮助我们来解决问题的
            解决的问题的时候碰到了类似的问题就是来使用递归可以解决

        2.当我们给一个标识符,给他一个明确的含义了,那么从那之后,我们就已经可以使用
            这个标识符了


1.求水洼数
    小明家的前面有一个大草坡,但是这个草坪不平,上面有很多坑,当下雨后,坑里面
        就会积水,就会有水洼出现

        1 1 0 0 1
        1 1 0 0 1
        0 0 1 1 0
        ...

        1表示有水,0表示此处没水,一个点的水,就会和其他地方的点的水形成一个水洼
        求水洼数量


        思路:
            假设我们是一个4*4的矩阵来判断水洼数
            1 0 0 1
            0 1 1 0
            0 1 0 0
            1 1 1 1
            先把这个矩阵填充成一个6*6的矩阵
            填充的数据不影响我们的结果的

            ===>
            0 0 0 0 0 0
            0 1 0 0 1 0
            0 0 1 1 0 0
            0 0 1 0 0 0
            0 1 1 1 1 0
            0 0 0 0 0 0
            第一步应该是填充矩阵

            然后开始遍历数组,找水洼,因为每次找到一个水坑之后又要判断他的上下左右是否有水
            为了避免被找过的水坑被重复查找,每次查找到有水的水坑之后,水坑数+1 
            就给他标记为没有水了,再去找他上下左右的水坑


            /*
                函数名:water  负责每次找到水坑之后,把它附近的也全部查找了
                参数列表:
                    二维数组,输入每次找到的有水的水坑坐标
                返回值:
                    void
            */
            void water(int a[][6],int m,int i,int j)
            {
                if(a[i][j] == 1)//i,j坐标上的水坑是有水
                {
                    a[i][j] = 0;
                    water(a,6,i-1,j);
                    water(a,6,i+1,j);
                    water(a,6,i,j-1);
                    water(a,6,i,j+1);
                    //把它所有相关的水坑都记作了一个
                }
            }


            /*
                函数名:water_num 查找水洼的数量
                参数列表:二维数组 
                返回值:水洼的数量

            */
            int water_num(int a[][6],int m)
            {
                int i,j;
                int sum = 0;
                for(i = 1;i < 5;i++)
                {
                    for(j = 1;j<m-1;j++)
                    {
                        //每次找到一个有水的水坑,就把它相关的全部计算下来
                        if(a[i][j] == 1)
                        {
                            sum++;
                            water(a,6,i,j);//把这个水坑相关的全部清0
                        }
                    }
                }
                return sum;
            }







2.大家可以去了解一个经典的递归题目
    汉诺塔题目




3.大家去了解以下
    gets() getchar() scanf()的区别


