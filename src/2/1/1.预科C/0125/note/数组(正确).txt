0.问题的引入
    现在我想定义一个变量保存唐清阳的年龄
    int age = 20;

    现在需要全班46个同学的年龄
    int age1,age2,age3...,age46;

    显然,这个方法不科学
    我们想找到一个方法,一次性定义一组相同数据类型的变量?

    数组

1.数组
    什么是数组?
        一组具有相同类型的数据元素的(有序)集合 

    在C语言中:
        一维数组
        二维数组
        ...
        n维数组
        实际上,我们都是可以看作一维数组来进行理解


2.一维数组 
    (1)定义语法
        数据类型 数组名[整型表达式];
        数据类型 数组名[整型表达式] = {初始化列表};

            "数据类型":不是数组的类型,是数组中 数据元素 的类型
                C语言中的任意合法数据类型都可以

            "数组名":数组的名字,符合C语言标识符的规范

            "整型表达式":指定数组元素的个数,为常量和常量表达式

            ==================================================
                C99 "可变长数组" :指定元素个数的时候,可以用变量
                    int n = 2;//变量不能被static ,extern所修饰
                    int a[n];//定义的时候 不能初始化
            ==================================================

            注意:
                在C语言中,定义数组的时候,一定要指定数组元素的个数
                或者是能够推导出数组元素的个数

        例子:
            int a[5];//定义了一个一维数组,数组名为a,数组元素的类型是int

            char b[5];//定义了一个一维数组,数组名为b,数组元素的类型是char

            int age[46];

    (2)数组元素的引用
        int age[46];//定义了一个名字为age的一维数组,里面有46个int类型的元素

        引用数组元素的方法:     "下标法"
            数组名[下标]  
            "下标":C语言规定,数组元素的下标都是从0开始

            比如:
                int a[5];
                a[0],a[1],a[2],a[3],a[4]
                引用数组的第四个元素 a[3]

        引用数组元素和引用变量是一样的
            数组元素也有左值和右值

            左值:变量名对应的那个空间的地址
                a[3] = 18;

            右值:这个变量本身的值
                int b = a[3];   // b-> 18
                a[0] = a[3];    // a[0] - > 18

    (3)数组在内存中的存放
        在C语言中,是用一组地址连续的储存单元,从低地址到高地址,一次存放
        数组的每一个数据
        先存放 a[0]
        a[0] 后面就是 a[1]
        a[1] 后面就是 a[2]
        ...

        例子:
            int a[5];
            //a[0] a[1] a[2] a[3] a[4] 
            
            %p:打印对象的地址(以十六进制的形式打印出来)

    (4)数组元素的初始化 
        初始化:
            在定义对象的时候,指定这个对象的值
        
        (1)全部初始化
            int a[10] = {1,2,3,4,5,6,7,8,9,10};
            注意:每个元素的值之间是用逗号隔开的

                a[6] = 7;//数组元素的下标是从0开始

        (2)部分初始化
            对部分的元素进行初始化,后面的没有被初始化的自动置0

            例子:
                int a[10] = {2,3};
                ===>
                int a[10] = {2,3,0,0,0,0,0,0,0,0};

                //定义一个数组,把里面的元素全部初始化为0
                int a[10] = {0};
                ===>
                int a[10] = {0,0,0,0,0,0,0,0,0,0};

        (3)如果对数组进行全部初始化,那么我们可以不指定数组的元素个数
            int a[] = {1,2,3,4,5,6};

            ===> int a[6] = {1,2,3,4,5,6};

        注意:
            只有在定义数组的时候,才可以指定数组的全部元素的值
            int a[5] = {1,2,3,4,5};//right

            int a[5];
            a[5] = {1,2,3,4,5};//a[n] ==> 引用数组的某个元素的  error
            a = {1,2,3,4,5};//error

            正确方法:
                a[0] = 1;
                a[1] = 2;
                ...

            不能够直接对数组名来进行赋值,只有定义的时候才能初始化

    

    练习:
        1.定义一个一维数组,里面有5个int类型的变量,从键盘来输入每一个元素的值
            并且把这个数组打印出来
            对数组进行遍历：
                遍历:对所有元素都进行访问
            利用循环的方式来输入和输出整个数组

            代码实现:
                int a[5];
                
                int i;
                //输入
                for(i = 0;i < 5;i++)
                {
                    scanf("%d",&a[i]);
                }

                //输出
                for(i = 0;i < 5;i++)
                {
                    printf("%d ",a[i]);
                }
                printf("\n");




        2.定义一个int类型的数组,里面有十个元素,从键盘上获取每一个元素的值,
            求这个数组的最大值,最小值,所有元素之和

            最大值:假设数组的第一个是最大值,往后一直遍历.找到比它大的数就更新最大值
            最小值:假设数组的第一个元素是最小值,往后一直遍历.找到比它小的数就更新最小值
            和:把数组的所有元素相加就OK了      

            代码实现:
                int a[10];
                int i;
                for(i = 0;i < 10;i++)
                {
                    scanf("%d",&a[i]);
                }      
                int max = a[0];
                int min = a[0];
                int sum = 0;

                for(i = 0;i < 12;i++)
                {
                    //求和
                    sum = sum + a[i];

                    if(a[i] > max)
                    {
                        max = a[i];
                    }

                    if(a[i] < min)
                    {
                        min = a[i];
                    }
                } 

                printf("该数组的和为%d,最大值是%d,最小值是%d\n",sum,max,min);
                return 0;



        3.判断一个整型数组a[10],是否为递增数组
            数组是自己输入也可以,你直接定义也可以

            递增:数字越来越大
                1 2 3 4 5 6 7 8 9 10 是 
                1 2 3 5 4 6 7 8 9 10 不是 
                1 2 3 3 4 6 7 8 9 10 不是 

            算法实现:
                算法一:标志位
                int main()
                {
                    int a[10];
                    int i;
                    for(i = 0;i < 10;i++)
                    {
                        scanf("%d",&a[i]);
                    }  
                    int flag = 1;//标志位,如果是1就递增,如果是0就不是
                    //比较数组中的元素
                    for(i = 0;i < 9;i++)//因为每次都和后一位比较,所以只需要访问到倒数第二个就好了
                    {
                        if(a[i] >= a[i+1])
                        {
                            flag = 0;
                            break;
                        }
                    }

                    //判断标志位
                    if(flag == 1)
                    {
                        printf("该数组是递增数组\n");
                    }
                    else
                    {
                        printf("该数组不是递增数组\n");
                    }
                }


                算法二:
                    for(i = 0;i < 9;i++)
                    {
                        if(a[i] >= a[i+1])
                        {
                            break;
                        }
                    }
                    (i == 9)? printf("递增\n"):printf("不是递增\n");

                算法三:
                    for(i = 0;i < 9;i++)
                    {
                        if(a[i] >= a[i+1])
                        {
                            printf("不是递增\n");
                            return 0;
                        }
                    }
                    printf("递增\n");

        4.不用排序(数组是一个无序的),找第二大的那个数
            除了老大,剩下就是老二

            思路:
                直接求好求吗?
                    不好求

                可以先求出老大,把它记录下来
                再来求我们老二,只要它不是老大,而且是剩余元素中最大的值

                #include <limits.h>     cd /usr/include 里面有很多头文件

                    INT_MIN int类型能够表示的最小的数

                代码实现:
                    int max = a[0];
                    int second = INT_MIN;   //第二大的数
                    int a[10];
                    int i;
                    for(i = 0;i < 10;i++)
                    {
                        scanf("%d",&a[i]);
                    } 

                    for(i = 0;i < 10;i++)
                    {
                        if(a[i] > max)
                        {
                            max = a[i];
                        }
                    }
                    for(i = 0;i < 10;i++)
                    {
                        //要大于我们的second并且不是最大值,那么就是第二大的数
                        if(a[i] > second && a[i]!=max)
                        {
                            second = a[i];
                        }
                    }
                    printf("第二大的数是%d\n",second);
                    

        define: 
            宏定义 
                "起外号"



作业:
    1.斐波那契数列
        求斐波那契数列的前二十项的和
        规定:
            第一项是1
            第二项也是1
            1 1 2 3 5 8 13..
            后一项是前两项的和
        思路:
            int a[20];
            a[0] = 1;
            a[1] = 1;

            //把剩下的十八项求出来
            假设求a[i]
            a[i] = a[i-1] + a[i-2];
            i从2开始
            for(i = 2;i < 20;i++)
            {
                a[i] = a[i-1] + a[i-2];
            }
            //对这个数组求和
            int sum = 0;
            for(i = 0;i < 20;i++)
            {
                sum += a[i];
            }



    2.在一个递增的数组中,找一个值为x的元素
        找到就输出这个值x
        没找到就输出-1
        (查找的效率)

        常规方法:
                遍历数组,找到值为x,就打印值 return程序
                如果没找到,结束循环之后,打印 -1

                代码实现:
                    int a[10] = {1,2,3,4,5,6,7,8,9,10};
                    int i;
                    int x;
                    scanf("%d",&x);
                    for(i = 0;i < 10;i++)
                    {
                        if(a[i] = x)
                        {
                            printf("%d\n",x);
                            return 0;
                        }
                    }
                    printf("-1");


                "二分查找法":
                    每次取起点和终点那个数的中间值
                    和目标值去对比
                    如果小于目标值,结果是在中间值和最大值中间
                    如果大于目标值,结果是在起点值和中间值中间
                    一直循环下去
                    而且我们这个循环不太确定这个次数的
                    更加注重条件  =====> while

                    每次这个新边界的取值,l和r重新给值的时候,一定要去注意它的条件

                    int a[10] = {1,2,3,4,5,6,7,8,9,10};
                    int x;
                    scanf("%d",&x);  
                    int l = 0;//保存第一个数的下标 因为值不一定连续,但是下标一定是连续的
                    int r = 9;//保存最后一个数的下标
                    int mid;//取中间值的下标的

                    while(l <= r)
                    {
                        mid = (l+r)/2;
                        //如果小于目标值,结果是在中间值和最大值中间
                        if(a[mid] < x)
                        {
                            l = mid+1;
                        }
                        else if(a[mid] > x)
                        {
                            r = mid-1;
                        }
                        else if(x == a[mid])
                        {
                            printf("%d\n",x);
                            return 0;
                        }
                    }
                    printf("-1\n");
                    


           
                    for(b=1;b<50;b++)
                    {
                        a[b]=a[b-1]+3;
                    }
                    while(i<j)
                    {
                        mid=(i+j)/2;
                        if(a[mid]<x)
                        {
                            i=mid;
                        }
                        else if(a[mid]>x)
                        {
                            j=mid;
                        }
                        else if(a[mid]==x)
                        {
                            printf("%d\n",x);
                            return 0;
                        }
                        if(j-i==1)\\i,j相连跳出循环
                        {
                            break;
                        }
                    }
                    printf("-1\n");

 
    3.不用排序,把一个数组中的负数 放到数组的最前面
        //只要输出是负数在前 正数在后就OK
        2 -5 1 3 4 -7 6 8
        -5 -7 2 1 3 4 6 8

        算法一:
            利用哨兵来帮我们实现功能
            派一个哨兵k,从左往右,去找负数
            每次找到负数之后,就把这个数和最左边位置上的那个数交换
            再进行第二次查找,找到下一个负数的时候就和左边第二个位置上的数交换
            重复这个这个过程,一直到找完整个数组位置

            i来表示左边用来交换的位置 i = 0
            每交换一次 i++

            代码实现:
                int i = 0;//每次用来交换的位置
                int k;//哨兵,找负数的 
                for(k = 0;k < 10;k++)
                {
                    if(a[k] < 0)//找到了一个负数
                    {
                        //交换位置
                        int temp = a[k];
                        a[k] = a[i];
                        a[i] = temp;
                        i++;//交换完了之后我们就要往后挪一个
                    }
                } 


        算法二:
            派一个哨兵i,从左往右
            派一个哨兵j,从右往左
            如果i找到了负数就继续往前走,i++
            如果j找到了非负数就继续往前走,j--
            当i找到非负数 j找到负数,就不会继续往前走
            需要进行交换

                2 -5 1 3 4 -7 6 8

            代码实现:
                //当i在j的左边,交换才是正确的
                for(i = 0,j = 9;i < j;)
                {
                    while(i < 9 && a[i] < 0)//用来找非负数,找到了i就会停在那里
                    {
                        i++;//
                    }
                    while(j > 0 && a[j] >= 0)//用来找负数,找到了j停在那里
                    {
                        j--;
                    }

                    //看i是否在j的左边
                    if(i < j)
                    {
                        int temp = a[i];
                        a[i] = a[j];
                        a[j] = temp;
                    }
                }


        算法三:
            for(i = 0;i < 10;i++)
            {
                if(a[i] < 0)
                {
                    printf("%d ",a[i]);
                }
            }
        
            for(i = 0;i < 10;i++)
            {
                if(a[i] > 0)
                {
                    printf("%d ",a[i]);
                }   
            }





    4.求一个数组中 连续子数组的和 的最大值(选做) int a[10]
        比如:
            1 -2 3 -4 6 7 -8 100 -101

            108是它的连续子数组最大的和

        暴力破解(穷举法)
            思路:
                所有的连续子数组的和我都求出来进行比较
                a[0]
                a[0] + a[1]
                a[0] + a[1] + a[2]
                ....

                ===>
                sum = 0;
                for(i = 0;i < 10;i++)
                {
                    sum += a[i];
                    if(sum > max)
                    {
                        max = sum;
                    }
                }

                a[1]
                a[1] + a[2]
                a[1] + a[2] + a[3]
                ....
                ===>
                sum = 0;
                for(i = 1;i < 10;i++)
                {
                    sum += a[i];
                    if(sum > max)
                    {
                        max = sum;
                    }
                }
                .....
                sum = 0;
                for(i = 9;i < 10;i++)
                {
                    sum += a[i];
                    if(sum > max)
                    {
                        max = sum;
                    }
                }

        代码实现:
            循环的嵌套
            int i,j;
            int sum;
            int max = a[0];

            for(j = 0;j < 10;j++)//第一个加的数是数组的第几个元素
            {
                sum = 0;
                for(i = j;i < 10;i++)
                {
                    sum += a[i];
                    if(sum > max)
                    {
                        max = sum;
                    }
                }
            }

            printf("%d\n",max);
        

                





思考题:
    5.如何对一个无序数组进行排序(从小到大)

        什么是排序?
            就是把一堆数据按照一定的规则进行一个排列

        冒泡排序
        选择排序

        快速排序
        希尔排序
        堆排序
        ...

3.两种基本排序
    (1)冒泡排序 
        核心思想:两两比较 互相交换
            相邻的两个数据会进行比较,比较完了之后再按照我们的比较结果
            和排序规则进行一个排序(交换)


        例子:
            int a[10] = {4,2,7,5,3,1,9,10,6,8};//以升序为例

        第一趟:
            第一个数和第二个数进行比较
            if(a[0] > a[1])     //第一次比较之前:4,2,7,5,3,1,9,10,6,8
            {
                a[0] <=> a[1]
            }
            //第一次比较之后:2,4,7,5,3,1,9,10,6,8

            第二个数和第三个数来比较
            if(a[1] > a[2])     //第二次比较之前:2,4,7,5,3,1,9,10,6,8
            {
                a[1] <=> a[2]
            }
            //第二次比较之后:2,4,7,5,3,1,9,10,6,8

            第三个数和第四个数进行比较
            if(a[2] > a[3])//第三次比较之前:2,4,7,5,3,1,9,10,6,8
            {
                a[2] <=> a[3]
            }
            //第三次比较之后:2,4,5,7,3,1,9,10,6,8

            第四个数和第五个数比较
            if(a[3] > a[4])//第四次比较之前:2,4,5,7,3,1,9,10,6,8
            {
                a[3] <=> a[4]
            }
            //第四次比较之后:2,4,5,3,7,1,9,10,6,8  

            第五个数和第六个数比较
            if(a[4] > a[5])//第五次比较之前:2,4,5,3,7,1,9,10,6,8 
            {
                a[4] <=> a[5]
            }     
            //第五次比较之后: 2,4,5,3,1,7,9,10,6,8 

            第六个数和第七个数比较
            if(a[5] > a[6])//第六次比较之前:2,4,5,3,1,7,9,10,6,8 
            {
                a[5] <=> a[6]
            }     
            //第六次比较之后: 2,4,5,3,1,7,9,10,6,8 

            第七个数和第八个数比较
            if(a[6] > a[7])//第七次比较之前:2,4,5,3,1,7,9,10,6,8 
            {
                a[6] <=> a[7]
            }     
            //第七次比较之后: 2,4,5,3,1,7,9,10,6,8           

            第八个数和第九个数比较
            if(a[7] > a[8])//第八次比较之前:2,4,5,3,1,7,9,10,6,8  
            {
                a[7] <=> a[8]
            }     
            //第八次比较之后: 2,4,5,3,1,7,9,6,10,8 

            第九个数和第十个数比较
            if(a[8] > a[9])//第九次比较之前:2,4,5,3,1,7,9,6,10,8 
            {
                a[8] <=> a[9]
            }     
            //第九次比较之后: 2,4,5,3,1,7,9,6,8,10


            比较之前:4,2,7,5,3,1,9,10,6,8

            第一趟比较完成后,把最大的那个数移动到了最后面

            第二趟比较完成后,第二大的数移动到了倒数第二个位置上
            ....
            第九趟比较完成之后,第九大的数移动到了倒数第九位置上
                    (最后两个数的位置也确定好了)

        代码实现这个怎么实现呢?
            循环的嵌套 
                有两个循环
                    一个是控制第几趟循环
                    一个是控制每趟循环里面第几次比较
                    每过一趟循环,比较的次数就要少一次

            每一趟的代码实现:
                第一趟比较:
                    int i;
                    从第一个数开始,一直往后进行比较到最后一个位置
                    每比较一次呢,i往后走一个

                    for(i = 0;i < 9;i++)
                    {
                        if(a[i] > a[i+1])
                        {
                            int temp = a[i];
                            a[i] = a[i+1];
                            a[i+1] = temp;
                        }
                    }

                第二趟:
                    for(i = 0;i < 8;i++)
                    {
                        if(a[i] > a[i+1])
                        {
                            int temp = a[i];
                            a[i] = a[i+1];
                            a[i+1] = temp;
                        }
                    }
                    ....

                第九趟:
                    for(i = 0;i < 1;i++)
                    {
                        if(a[i] > a[i+1])
                        {
                            int temp = a[i];
                            a[i] = a[i+1];
                            a[i+1] = temp;
                        }
                    }

            外循环来控制每一趟
            {
                内循环控制这一趟的比较次数
                {

                }
            }

            整体代码实现:
                int i,j;
                for(j = 0;j < 9;j++)//控制比较的趟数
                {
                    for(i = 0;i < 9-j;i++)//控制每趟比较多少次,次数跟趟数有关的
                    {
                        if(a[i] > a[i+1])
                        {
                            int temp = a[i];
                            a[i] = a[i+1];
                            a[i+1] = temp;
                        }  
                    }
                }

        上面这个代码我们是10个元素进行排序
            现在我有n个元素需要排序,麻烦您给我实现一下这个代码
                int i,j;
                for(j = 0;j < n-1;j++)//控制比较的趟数
                {
                    for(i = 0;i < n-1-j;i++)//控制每趟比较多少次,次数跟趟数有关的
                    {
                        if(a[i] > a[i+1])
                        {
                            int temp = a[i];
                            a[i] = a[i+1];
                            a[i+1] = temp;
                        }  
                    }
                }


    (2)选择排序
        思路:(升序)
            先找数组中的当前最大值,找到了就记录它的下标
            和最后一个元素进行交换

        
        例子:
            int a[10] = {4,2,7,5,3,1,9,10,6,8};//以升序为例

            遍历数组找最大值

            第一次选择:
                遍历一次数组(a[0] ~ a[9])
                4,2,7,5,3,1,9,10,6,8
                找到最大值,交换:
                4,2,7,5,3,1,9,8,6,10

            第二次选择:
                遍历一次数组(a[0] ~ a[8])
                4,2,7,5,3,1,9,8,6,10
                找到最大值,交换 
                4,2,7,5,3,1,6,8,9,10
                
                .....

            第九次选择:
                1 2 3 4 5 6 7 8 9 10

            编程建议:
                可以加一个判断,如果最大值已经在它应该在的位置的时候,我们就可以不需要交换

    代码实现:
        循环(控制是第多少次选择)
        {
            最大值和最大值下标
            找最大值的循环
            {}

            有一个判断是否位置已经对了
                位置交换
        }

        int i,j;
        int max;//最大值
        int max_i;//最大值下标 

        for(j = 0;j < 9;j++)//选择的次数
        {
            max = a[0];
            max_i = 0;
            for(i = 0;i < 10-j;i++)//找当前数组里的最大值
            {
                if(a[i] > max)
                {
                    max = a[i];
                    max_i = i;
                }
            }
            //判断是否位置已经对了
            if(max_i != 9-j)
            {
                int temp = a[9-j];
                a[9-j] = a[max_i];
                a[max_i] = temp;
            }

        }

        假设有n的元素需要排序

                int i,j;
                int max;//最大值
                int max_i;//最大值下标 

                for(j = 0;j < n-1;j++)//选择的次数
                {
                    max = a[0];
                    max_i = 0;
                    for(i = 0;i < n-j;i++)//找当前数组里的最大值
                    {
                        if(a[i] > max)
                        {
                            max = a[i];
                            max_i = i;
                        }
                    }
                    //判断是否位置已经对了
                    if(max_i != n-1-j)
                    {
                        int temp = a[n-1-j];
                        a[n-1-j] = a[max_i];
                        a[max_i] = temp;
                    }

                }


        冒泡    VS    选择

        冒泡:
            两两比较,互相交换 
            N个元素:
                最好情况:0次
                最坏情况:N-1次

            O(n^2)

        
        选择:
            找最大值,进行交换 
            N个元素 
                最多交换:N-1
                最小交换0次

            O(n^2)



==========================================================================

1.二维数组

    (1).问题的引入
        int a[3];//定义了一个一维数组,数组名字叫a,里面有3个int类型的元素
                a 是一个什么类型?
                    构造类型,一个有3个int元素的一个集合

            typeof()    ----> 求对象的数据类型
            typeof(4) ---> int 
            typeof('a') ---> char 

            typeof(a)   ---> ?
            
            int b;
            typeof(b) ---> int 

            假设我要你定义一个和a类型一样的变量c 

            数据类型 变量名;


            typeof(a) c;
            typeof(a)   ---> int [3]

            int [3] c  ===> C语言规定,括号不能和关键字靠在一块
            ====> int c[3];//定义一个变量,类型和a一样

            假设我还要定义4个和a一样的元素来组成一个数组,怎么定义
            数据类型 数组名[数组元素个数];
            typeof(a) d[4];
            int [3] d[4] ====> int d[4][3];

        从上面的分析可以得出一个结论:
            在C语言中,其实二维数组就是一个一维数组
                只不过这个一维数组的每个元素又是一个一维数组

            d[4][3]    四行三列

            d[0] _ _ _    
            d[1] _ _ _ 
            d[2] _ _ _ 
            d[3] _ _ _ 

    (2)二维数组的定义语法
        数据类型 数组名[行数][列数];//从矩阵的角度来看二维数组

        "数据类型":二维数组中元素的类型!!! 不是这个数组的类型
                C语言中的任意合法数据类型都可以

        "行数" "列数": 常量表达式 

        例子:
            int a[3][3];//数组名为a,有三行三列数据的二为数组,里面每个元素都是int类型

    (3)二维数组在内存中的存放形式
        int b[2][3];

        b[0] _ _ x
        b[1] y _ _

        二维数组的地址也是用一组连续的地址存放的
        按行来进行存放的,按照顺序 先存放第一行的第一个元素,在存放第一行的第二个元素....
        直到这一行存放完成,再再后面接着存放第二行的元素....一直到所有元素都存放完毕

        第一行x的地址和第二行y的地址是连续的

    (4)二维数组的元素的引用     下标法 
        语法:
            数组名[行下标][列下标]


            int b[3][3];

            b[0][0] b[0][1] b[0][2]
            b[1][0] b[1][1] b[1][2]
            b[2][0] b[2][1] b[2][2]

        引用二维数组的元素和引用变量是一样的,它有左值和右值
            左值:
                代表变量所对应的那块空间的地址
                b[0][0] = 2;
            
            右值:
                代表变量本身的值
                int a = b[0][0];  //a ===> 2


    (5)二维数组的初始化 
        我们在定义二维数组的时候,用{}给数组元素进行初始化


        1)给数组元素全部初始化
            int b[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};

        2)也可以直接将所有的元素放在一个{}里面 
            编译器会自动识别哪个是哪一行的
            int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};

        3)对部分元素进行初始化,其他未初始化的元素会自动置0
            int b[3][3] = {1,2,3};
            ===>
            int b[3][3] = {1,2,3,0,0,0,0,0,0};

            int b[3][3] = {{},{1,2},{3}};
            ===>
            int b[3][3] = {0,0,0,1,2,0,3,0,0};

        4)如果你对全部元素进行初始化的时候,可以省略行数,但是不能省略列数
            int n[][3] = {1,2,3,4,5,6,7,8,9,10,11,12};

            ===>4行3列

        注意:只有在定义数组的时候,才能进行初始化(才能对所有元素进行整体赋值)

        例子:
            int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};//right

            int a[3][3];
            //error
            a[3][3] = {1,2,3,4,5,6,7,8,9};
            a = {...};


    练习:
        1.定义一个二维数组int a[3][3],从键盘上输入每一个元素的值,并且,求这个数组的最大值
            最小值以及他们的和

            代码实现:
                int a[3][3];

                int i,j;
                for(i = 0;i < 3;i++)
                {
                    for(j = 0;j < 3;j++)
                    {
                        scanf("%d",&a[i][j]);
                    }
                }


                int max = a[0][0];
                int min = a[0][0];
                int sum = 0
                for(i = 0;i < 3;i++)
                {
                    for(j = 0;j < 3;j++)
                    {
                        if(a[i][j] > max)
                        {
                            max = a[i][j];
                        }
                        if(a[i][j] < min)
                        {
                            min = a[i][j];
                        }
                        sum += a[i][j];
                    }
                }


                printf("max:%d min:%d sum:%d\n",max,min,sum);




        2.把一个二维数组的行列互换
            int a[3][4];
            ====>
            int a[4][3];

            1  2  3  4              1 5 9
            5  6  7  8      --->    2 6 10
            9  10 11 12             3 7 11  
                                    4 8 12 


            "以结果为导向"
            代码实现:
                int a[3][4];

                int i,j;
                for(i = 0;i < 3;i++)
                {
                    for(j = 0;j < 4;j++)
                    {
                        scanf("%d",&a[i][j]);
                    }
                }

                printf("原来输入的数组是:\n");
                for(i = 0;i < 3;i++)
                {
                    for(j = 0;j < 4;j++)
                    {
                        scanf("%d ",&a[i][j]);
                    }
                    printf("\n");
                }

                //直接定义一个四行三列的数组
                int b[4][3];
                for(i = 0;i < 3;i++)
                {
                    for(j = 0;j < 4;j++)
                    {
                        b[j][i] = a[i][j];
                    }
                }

                for(i = 0;i < 4;i++)
                {
                    for(j = 0;j < 3;j++)
                    {
                        printf("%d ",b[i][j]);
                    }
                    printf("\n");
                }




2.数组的类型 
    int b[10];
    数组b:是一个含有10个int类型元素的数组

    数组b的类型
        有十个int类型元素的数组的类型

        typeof()


    typedef:
        给一种数据类型,定义一个新的名字,取别名

    定义语法:
        typedef 旧的类型名 新的类型名;

    例子:
        typedef unsigned char uint_8;

        uint_8 ====> unsigned char 

        u_16
        u_32

        int b[10];
        typeof(b) ---> int [10]

        typedef int [10] INT10 =====> typedef int(INT10) [10];

        INT10 a;====> int a[10];


练习:
    1.求 "山顶元素" 的个数
        山顶:比四周都要高  (值比他上下左右都要大)
        1   9  -8  7
        11 -12  3  1
        10  6   4  5
        1   0   3  8
        
        山顶元素:9 7 11 8 


        注意:
            有些数他是没有上下左右的 

                    1   9  -8  7
                    11 -12  3  1
                    10  6   4  5
                    1   0   3  8
        
        算法一:
            暴力破解
            假设某一个元素a[i][j]
            那么这个数要是山顶元素的话需要满足什么条件?

            if(a[i][j]比上面的数要大 && a[i][j]比下面的数要打 && a[i][j]比左边的数要打
                    && a[i][j]比右边的数要大)
            {
                山顶元素;
            }
            ===>
                比上面的数要大:
                    上面没有数 || 上面有一个数,并且大于上面这个数
                        i == 0  || a[i][j] > a[i-1][j]

                比下面的数要大:
                    下面没有数 || 下面有一个数,并且大于下面这个数 
                        i == 3 || a[i][j] > a[i+1][j]

                比左边的数要大:
                    左边没有数 || 左边有一个数,并且大于左边这个数
                        j == 0 || a[i][j] > a[i][j-1]

                比右边的数要大
                    右边没有数 || 右边有一个数,并且大于右边这个数
                        j == 3 || a[i][j] > a[i][j+1]
                    1   9  -8  7
                    11 -12  3  1
                    10  6   4  5
                    1   0   3  8
        代码实现:
            int a[4][4] = {1,9,-8,7,11,-12,3,1,10,6,4,5,1,0,3,8};

            int i,j;
            int count = 0;//计算山顶元素的个数

            for(i = 0;i < 4;i++)
            {
                for(j = 0;j < 4;j++)
                {
                    if((i == 0 ||a[i][j] > a[i-1][j]) && (i == 3 || a[i][j] > a[i+1][j]) 
                        && (j == 0 || a[i][j] > a[i][j-1]) && (j == 3 || a[i][j] > a[i][j+1]))
                    {
                        printf("%d ",a[i][j]);
                        count++;
                    }
                }
            }
            printf("\n");
            printf("山顶元素有%d个\n",count);
    

    算法二:
        算法一Plus

        原来我的数组会出现四周没有数,导致我无法用最简单的条件来判断
        那么可不可以这样?

                  x  x   x   x  x x
                  x  1   9  -8  7 x
                  x  11 -12  3  1 x
                  x  10  6   4  5 x
                  x  1   0   3  8 x
                  x  x   x   x  x x 

        补充的数据不能影响结果的
            把四周补充的数据补充INT_MIN,这样的话它一定比我们原来边界的值要小


        第二个,是不是要定义一个更大的数组来存放我们的数据
            是 ,除了原数组,还需要定义一个更大的数组来存放数据

        代码实现:
            int x = INT_MIN;//注意头文件
            int a[4][4] = {1,9,-8,7,11,-12,3,1,10,6,4,5,1,0,3,8};
            int b[6][6] = {0};//尽量先把这个数组初始化一下

            //扩充原数组
            int i,j;
            int count = 0;

            for(i = 0;i < 6;i++)
            {
                for(j = 0;j < 6;j++)
                {
                    //当是我们新数组的边界的时候,给一个极小值
                    if(i == 0||i == 5||j == 0||j == 5)
                    {
                        b[i][j] = x;
                    }
                    else
                    {
                        b[i][j] = a[i-1][j-1];//原数组和他比较一下就知道了
                    }
                }
            }

            //只需要去判断原数组的数据部分就好了
            for(i = 1;i < 5;i++)
            {
                for(j = 1;j < 5;j++)
                {
                    if(b[i][j] > b[i-1][j] & b[i][j] > b[i+1][j] && b[i][j] > b[i][j-1]
                        & b[i][j] > b[i][j+1])
                    {
                        printf("%d ",b[i][j]);
                        count++;
                    }
                }
            }
            printf("\n");
            printf("山顶元素有%d个\n",count);


数组整个知识回顾:
    1.一维数组 
        数组的概念:
            同一类型的元素的集合

        数组的定义语法:
            数据类型 数组名[数组元素个数];

        数组的存放:
            %p:打印地址,以十六进制的方式输出地址
            连续的 

        数组元素的引用:
            下标从0开始

        数组的初始化 
            全部初始化
            部分初始化 
                把一个数组初始化为0
            只有在定义数组的时候,才可以指定数组的全部元素的值
        
    2.冒泡排序 选择排序 
        知道它是怎么用的,并且能够 "倒背如流"

    3.二维数组 


    
    容易出错的点:
        1.下标引用的时候越界了,int a[3];  a[3] ===> 内存的错误访问

        2.for(); ---> 要注意不要加这个分号了
            if();

        3.赋值运算符 和 逻辑相等运算符号搞反了
            =               == 

        4.先定义了数组,但是还没有赋值,就引用了数组的元素 //未知的值
            建议:
                不管你后面要用这个数组去干吗,一开始都初始化为0好些


作业:
    1.求一个二维数组的 "鞍点"
        鞍点:他是这一行最大的值,但是又是它所在的那一列最小的值
        1  2    3    4
        5  6    7    8
        9  10   11   12
        13 14   15   16 

        鞍点:4
        条件:
            行最大 && 列最小

        思路:
            每一次都一行一行的去找这一行最大的那个数.找到了之后,我记录下来它的列坐标
            直接在这一列进行比较,如果有比它小的数,那么他就不是鞍点(退出本次查找),继续进行
            下一次查找.如果它是这一列最小的数,那么就对这个数进行输出,表示他是鞍点
            
            //找第0行
            max = a[0][0];//记录最大值
            max_i = 0;//记录最大值的列下标
            flag = 1;//1表示是的,0表示不是
            for(i = 0;i < 4;i++)//找这一行的最大值
            {
                if(a[0][i] > max)
                {
                    max = a[0][i];
                    max_i = i;
                }
            }

            //判断这个最大值是不是它那一列(max_i列)的最小值

            for(i = 0;i < 4;i++)
            {
                //zhi只要找到了一个比它小的数,那么就不用找了
                if(a[i][max_i] < max)//max是之前找的那个行最大值
                {
                    flag = 0;
                    break;
                }
            }

            //判断标志位
            if(flag == 1)
            {
                printf("%d ",max);
            }

            //后面还有3行要找

            代码实现:
                int i,j,k;//循环变量
                int max;//保存最大值,同时也要用来判断是否是列最小值
                int max_i;//最大值所在的列下标

                int flag;//标志位,用来判断是否为鞍点

                for(i = 0;i < 4;i++)//遍历所有行
                {
                    max = a[i][0];//每次最大值都初始化为该行第一个
                    flag = 1;
                    for(j = 0;j < 4;j++)//找这一行的最大值
                    {
                        if(a[i][j] > max)
                        {
                            max = a[i][j];
                            max_i = j;
                        }
                    }

                    //判断是否这个行最大值是这一列的最小值
                    for(k = 0;k < 4;k++)
                    {
                        if(a[k][max_i] < max)//如果在这一列找到一个比行最大值小的值,那么就不是鞍点 
                        {
                            flag = 0;
                            break;
                        }
                    }
                    if(flag == 1)
                    {
                        printf("%d\n",max);
                    }
                }

                return 0;




    2.高数巨占座问题
        详情见图片:
        假设输入n行m列的数组
        输入要占的座位数为k 
        1 0 0 1
        0 0 0 0
        1 1 1 0
        0 1 0 1

        思路:
            遍历数组,我们是要找连续的0,如果有1
            隔开了,空座就不连续了

            假设要占k个座位,是不是就要至少找k个连续的0
            找到k个之后,后面每多一个0.是不是就多一种
            坐的方法

            //找第0行的连续的0
            zero_num = 0;//记录连续的0的个数
            for(i = 0;i < m;i++)
            {
                if(a[0][i] == 0)
                {
                    zero_num++;//如果有一个0,连续的0的数量就+1
                }
                else
                {
                    zero_num = 0;//如果是一个1,那么连续0的个数就从0开始
                }

                if(zero_num >= k)
                {
                    count++;
                }
            }


            代码实现:
                int n,m,k;//分别定义了我们这个行 列 要占的座位数
                scanf("%d%d%d",&n,&m,&k);
                int a[n][m];
                int i,j;//循环变量

                //输入数组
                for(i = 0; i < n;i++)
                {
                    for(j = 0;j < m;j++)
                    {
                        scanf("%d",&a[n][m]);
                    }
                }

                int zero_num = 0;//记录连续的0的个数
                int count = 0;//可以坐的位置数
                //遍历数组找位置坐
                for(i = 0;i < n;i++)
                {
                    zero_num = 0;//每一行都要重新记录连续位置的个数
                    for(j = 0;j < m;j++)//找一行的空座位
                    {
                        if(a[i][j] == 0)
                        {
                            zero_num++;//连续的座位就+1
                        }
                        else
                        {
                            zero_num = 0;//否则就-1
                        }

                        //当空座>=要占座位数的时候, count++
                        if(zero_num >= k)
                        {
                            count++;
                        }
                    }
                }

                printf("有%d种的坐法\n",count);


